// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false 2021 is not a leap year validateJSON() fails 1`] = `"should be formatted as date but is '2021-02-29' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false ISO8601 / non-RFC3339: YYYYMMDD without dashes (2023-03-28) validateJSON() fails 1`] = `"should be formatted as date but is '20230328' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false ISO8601 / non-RFC3339: week number implicit day of week (2023-01-02) validateJSON() fails 1`] = `"should be formatted as date but is '2023-W01' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false ISO8601 / non-RFC3339: week number rollover to next year (2023-01-01) validateJSON() fails 1`] = `"should be formatted as date but is '2022W527' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false ISO8601 / non-RFC3339: week number with day of week (2023-03-28) validateJSON() fails 1`] = `"should be formatted as date but is '2023-W13-2' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 29 days in February (normal) validateJSON() fails 1`] = `"should be formatted as date but is '2021-02-29' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 30 days in February (leap) validateJSON() fails 1`] = `"should be formatted as date but is '2020-02-30' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 31 days in April validateJSON() fails 1`] = `"should be formatted as date but is '2020-04-31' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 31 days in June validateJSON() fails 1`] = `"should be formatted as date but is '2020-06-31' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 31 days in November validateJSON() fails 1`] = `"should be formatted as date but is '2020-11-31' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 31 days in September validateJSON() fails 1`] = `"should be formatted as date but is '2020-09-31' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 32 days in August validateJSON() fails 1`] = `"should be formatted as date but is '2020-08-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 32 days in December validateJSON() fails 1`] = `"should be formatted as date but is '2020-12-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 32 days in January validateJSON() fails 1`] = `"should be formatted as date but is '2020-01-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 32 days in July validateJSON() fails 1`] = `"should be formatted as date but is '2020-07-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 32 days in March validateJSON() fails 1`] = `"should be formatted as date but is '2020-03-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 32 days in May validateJSON() fails 1`] = `"should be formatted as date but is '2020-05-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with 32 days in October validateJSON() fails 1`] = `"should be formatted as date but is '2020-10-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false a invalid date string with invalid month validateJSON() fails 1`] = `"should be formatted as date but is '2020-13-01' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false an invalid date string validateJSON() fails 1`] = `"should be formatted as date but is '06/19/1963' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false invalid month validateJSON() fails 1`] = `"should be formatted as date but is '1998-13-01' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false invalid month-day combination validateJSON() fails 1`] = `"should be formatted as date but is '1998-04-31' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false invalid non-ASCII '৪' (a Bengali 4) validateJSON() fails 1`] = `"should be formatted as date but is '1963-06-1৪' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false non-padded day dates are not valid validateJSON() fails 1`] = `"should be formatted as date but is '1998-01-1' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false non-padded month dates are not valid validateJSON() fails 1`] = `"should be formatted as date but is '1998-1-20' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = false only RFC3339 not all of ISO 8601 are valid validateJSON() fails 1`] = `"should be formatted as date but is '2013-350' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true 2021 is not a leap year validateJSON() fails 1`] = `"should be formatted as date but is '2021-02-29' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true ISO8601 / non-RFC3339: YYYYMMDD without dashes (2023-03-28) validateJSON() fails 1`] = `"should be formatted as date but is '20230328' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true ISO8601 / non-RFC3339: week number implicit day of week (2023-01-02) validateJSON() fails 1`] = `"should be formatted as date but is '2023-W01' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true ISO8601 / non-RFC3339: week number rollover to next year (2023-01-01) validateJSON() fails 1`] = `"should be formatted as date but is '2022W527' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true ISO8601 / non-RFC3339: week number with day of week (2023-03-28) validateJSON() fails 1`] = `"should be formatted as date but is '2023-W13-2' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 29 days in February (normal) validateJSON() fails 1`] = `"should be formatted as date but is '2021-02-29' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 30 days in February (leap) validateJSON() fails 1`] = `"should be formatted as date but is '2020-02-30' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 31 days in April validateJSON() fails 1`] = `"should be formatted as date but is '2020-04-31' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 31 days in June validateJSON() fails 1`] = `"should be formatted as date but is '2020-06-31' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 31 days in November validateJSON() fails 1`] = `"should be formatted as date but is '2020-11-31' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 31 days in September validateJSON() fails 1`] = `"should be formatted as date but is '2020-09-31' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 32 days in August validateJSON() fails 1`] = `"should be formatted as date but is '2020-08-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 32 days in December validateJSON() fails 1`] = `"should be formatted as date but is '2020-12-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 32 days in January validateJSON() fails 1`] = `"should be formatted as date but is '2020-01-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 32 days in July validateJSON() fails 1`] = `"should be formatted as date but is '2020-07-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 32 days in March validateJSON() fails 1`] = `"should be formatted as date but is '2020-03-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 32 days in May validateJSON() fails 1`] = `"should be formatted as date but is '2020-05-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with 32 days in October validateJSON() fails 1`] = `"should be formatted as date but is '2020-10-32' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true a invalid date string with invalid month validateJSON() fails 1`] = `"should be formatted as date but is '2020-13-01' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true an invalid date string validateJSON() fails 1`] = `"should be formatted as date but is '06/19/1963' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true invalid month validateJSON() fails 1`] = `"should be formatted as date but is '1998-13-01' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true invalid month-day combination validateJSON() fails 1`] = `"should be formatted as date but is '1998-04-31' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true invalid non-ASCII '৪' (a Bengali 4) validateJSON() fails 1`] = `"should be formatted as date but is '1963-06-1৪' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true non-padded day dates are not valid validateJSON() fails 1`] = `"should be formatted as date but is '1998-01-1' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true non-padded month dates are not valid validateJSON() fails 1`] = `"should be formatted as date but is '1998-1-20' instead"`;

exports[`tests/draft2020-12/optional/format/date.json validation of date strings outputFormat = verbose, failFast = true only RFC3339 not all of ISO 8601 are valid validateJSON() fails 1`] = `"should be formatted as date but is '2013-350' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = false an invalid closing Z after time-zone offset validateJSON() fails 1`] = `"should be formatted as date-time but is '1963-06-19T08:30:06.28123+01:00Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = false an invalid date-time past leap second, UTC validateJSON() fails 1`] = `"should be formatted as date-time but is '1998-12-31T23:59:61Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = false an invalid date-time string validateJSON() fails 1`] = `"should be formatted as date-time but is '06/19/1963 08:30:06 PST' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = false an invalid date-time with leap second on a wrong hour, UTC validateJSON() fails 1`] = `"should be formatted as date-time but is '1998-12-31T22:59:60Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = false an invalid date-time with leap second on a wrong minute, UTC validateJSON() fails 1`] = `"should be formatted as date-time but is '1998-12-31T23:58:60Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = false an invalid day in date-time string validateJSON() fails 1`] = `"should be formatted as date-time but is '1990-02-31T15:59:59.123-08:00' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = false an invalid offset in date-time string validateJSON() fails 1`] = `"should be formatted as date-time but is '1990-12-31T15:59:59-24:00' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = false invalid non-ASCII '৪' (a Bengali 4) in date portion validateJSON() fails 1`] = `"should be formatted as date-time but is '1963-06-1৪T00:00:00Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = false invalid non-ASCII '৪' (a Bengali 4) in time portion validateJSON() fails 1`] = `"should be formatted as date-time but is '1963-06-11T0৪:00:00Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = false invalid non-padded day dates validateJSON() fails 1`] = `"should be formatted as date-time but is '1963-06-1T08:30:06.283185Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = false invalid non-padded month dates validateJSON() fails 1`] = `"should be formatted as date-time but is '1963-6-19T08:30:06.283185Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = false only RFC3339 not all of ISO 8601 are valid validateJSON() fails 1`] = `"should be formatted as date-time but is '2013-350T01:01:01' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = true an invalid closing Z after time-zone offset validateJSON() fails 1`] = `"should be formatted as date-time but is '1963-06-19T08:30:06.28123+01:00Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = true an invalid date-time past leap second, UTC validateJSON() fails 1`] = `"should be formatted as date-time but is '1998-12-31T23:59:61Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = true an invalid date-time string validateJSON() fails 1`] = `"should be formatted as date-time but is '06/19/1963 08:30:06 PST' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = true an invalid date-time with leap second on a wrong hour, UTC validateJSON() fails 1`] = `"should be formatted as date-time but is '1998-12-31T22:59:60Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = true an invalid date-time with leap second on a wrong minute, UTC validateJSON() fails 1`] = `"should be formatted as date-time but is '1998-12-31T23:58:60Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = true an invalid day in date-time string validateJSON() fails 1`] = `"should be formatted as date-time but is '1990-02-31T15:59:59.123-08:00' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = true an invalid offset in date-time string validateJSON() fails 1`] = `"should be formatted as date-time but is '1990-12-31T15:59:59-24:00' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = true invalid non-ASCII '৪' (a Bengali 4) in date portion validateJSON() fails 1`] = `"should be formatted as date-time but is '1963-06-1৪T00:00:00Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = true invalid non-ASCII '৪' (a Bengali 4) in time portion validateJSON() fails 1`] = `"should be formatted as date-time but is '1963-06-11T0৪:00:00Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = true invalid non-padded day dates validateJSON() fails 1`] = `"should be formatted as date-time but is '1963-06-1T08:30:06.283185Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = true invalid non-padded month dates validateJSON() fails 1`] = `"should be formatted as date-time but is '1963-6-19T08:30:06.283185Z' instead"`;

exports[`tests/draft2020-12/optional/format/date-time.json validation of date-time strings outputFormat = verbose, failFast = true only RFC3339 not all of ISO 8601 are valid validateJSON() fails 1`] = `"should be formatted as date-time but is '2013-350T01:01:01' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = false an invalid duration string validateJSON() fails 1`] = `"should be formatted as duration but is 'PT1D' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = false element without unit validateJSON() fails 1`] = `"should be formatted as duration but is 'P1' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = false elements out of order validateJSON() fails 1`] = `"should be formatted as duration but is 'P2D1Y' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = false invalid non-ASCII '২' (a Bengali 2) validateJSON() fails 1`] = `"should be formatted as duration but is 'P২Y' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = false missing time separator validateJSON() fails 1`] = `"should be formatted as duration but is 'P1D2H' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = false no date or time elements present validateJSON() fails 1`] = `"should be formatted as duration but is 'PT' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = false no elements present validateJSON() fails 1`] = `"should be formatted as duration but is 'P' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = false no time elements present validateJSON() fails 1`] = `"should be formatted as duration but is 'P1YT' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = false time element in the date position validateJSON() fails 1`] = `"should be formatted as duration but is 'P2S' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = false weeks cannot be combined with other units validateJSON() fails 1`] = `"should be formatted as duration but is 'P1Y2W' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = true an invalid duration string validateJSON() fails 1`] = `"should be formatted as duration but is 'PT1D' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = true element without unit validateJSON() fails 1`] = `"should be formatted as duration but is 'P1' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = true elements out of order validateJSON() fails 1`] = `"should be formatted as duration but is 'P2D1Y' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = true invalid non-ASCII '২' (a Bengali 2) validateJSON() fails 1`] = `"should be formatted as duration but is 'P২Y' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = true missing time separator validateJSON() fails 1`] = `"should be formatted as duration but is 'P1D2H' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = true no date or time elements present validateJSON() fails 1`] = `"should be formatted as duration but is 'PT' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = true no elements present validateJSON() fails 1`] = `"should be formatted as duration but is 'P' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = true no time elements present validateJSON() fails 1`] = `"should be formatted as duration but is 'P1YT' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = true time element in the date position validateJSON() fails 1`] = `"should be formatted as duration but is 'P2S' instead"`;

exports[`tests/draft2020-12/optional/format/duration.json validation of duration strings outputFormat = verbose, failFast = true weeks cannot be combined with other units validateJSON() fails 1`] = `"should be formatted as duration but is 'P1Y2W' instead"`;

exports[`tests/draft2020-12/optional/format/email.json validation of e-mail addresses outputFormat = verbose, failFast = false an invalid IPv4-address-literal validateJSON() fails 1`] = `"should be formatted as email but is 'joe.bloggs@[127.0.0.300]' instead"`;

exports[`tests/draft2020-12/optional/format/email.json validation of e-mail addresses outputFormat = verbose, failFast = false an invalid domain validateJSON() fails 1`] = `"should be formatted as email but is 'joe.bloggs@invalid=domain.com' instead"`;

exports[`tests/draft2020-12/optional/format/email.json validation of e-mail addresses outputFormat = verbose, failFast = false an invalid e-mail address validateJSON() fails 1`] = `"should be formatted as email but is '2962' instead"`;

exports[`tests/draft2020-12/optional/format/email.json validation of e-mail addresses outputFormat = verbose, failFast = false dot after local part is not valid validateJSON() fails 1`] = `"should be formatted as email but is 'test.@example.com' instead"`;

exports[`tests/draft2020-12/optional/format/email.json validation of e-mail addresses outputFormat = verbose, failFast = false dot before local part is not valid validateJSON() fails 1`] = `"should be formatted as email but is '.test@example.com' instead"`;

exports[`tests/draft2020-12/optional/format/email.json validation of e-mail addresses outputFormat = verbose, failFast = false two subsequent dots inside local part are not valid validateJSON() fails 1`] = `"should be formatted as email but is 'te..st@example.com' instead"`;

exports[`tests/draft2020-12/optional/format/email.json validation of e-mail addresses outputFormat = verbose, failFast = true an invalid IPv4-address-literal validateJSON() fails 1`] = `"should be formatted as email but is 'joe.bloggs@[127.0.0.300]' instead"`;

exports[`tests/draft2020-12/optional/format/email.json validation of e-mail addresses outputFormat = verbose, failFast = true an invalid domain validateJSON() fails 1`] = `"should be formatted as email but is 'joe.bloggs@invalid=domain.com' instead"`;

exports[`tests/draft2020-12/optional/format/email.json validation of e-mail addresses outputFormat = verbose, failFast = true an invalid e-mail address validateJSON() fails 1`] = `"should be formatted as email but is '2962' instead"`;

exports[`tests/draft2020-12/optional/format/email.json validation of e-mail addresses outputFormat = verbose, failFast = true dot after local part is not valid validateJSON() fails 1`] = `"should be formatted as email but is 'test.@example.com' instead"`;

exports[`tests/draft2020-12/optional/format/email.json validation of e-mail addresses outputFormat = verbose, failFast = true dot before local part is not valid validateJSON() fails 1`] = `"should be formatted as email but is '.test@example.com' instead"`;

exports[`tests/draft2020-12/optional/format/email.json validation of e-mail addresses outputFormat = verbose, failFast = true two subsequent dots inside local part are not valid validateJSON() fails 1`] = `"should be formatted as email but is 'te..st@example.com' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = false a host name containing illegal characters validateJSON() fails 1`] = `"should be formatted as hostname but is 'not_a_valid_host_name' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = false a host name starting with an illegal character validateJSON() fails 1`] = `"should be formatted as hostname but is '-a-host-name-that-starts-with--' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = false a host name with a component too long validateJSON() fails 1`] = `"should be formatted as hostname but is 'a-vvvvvvvvvvvvvvvveeeeeeeeeeeeeeeerrrrrrrrrrrrrrrryyyyyyyyyyyyyyyy-long-host-name-component' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = false contains underscore validateJSON() fails 1`] = `"should be formatted as hostname but is 'host_name' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = false ends with hyphen validateJSON() fails 1`] = `"should be formatted as hostname but is 'hostname-' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = false ends with underscore validateJSON() fails 1`] = `"should be formatted as hostname but is 'hostname_' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = false exceeds maximum label length validateJSON() fails 1`] = `"should be formatted as hostname but is 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijkl.com' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = false starts with hyphen validateJSON() fails 1`] = `"should be formatted as hostname but is '-hostname' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = false starts with underscore validateJSON() fails 1`] = `"should be formatted as hostname but is '_hostname' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = true a host name containing illegal characters validateJSON() fails 1`] = `"should be formatted as hostname but is 'not_a_valid_host_name' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = true a host name starting with an illegal character validateJSON() fails 1`] = `"should be formatted as hostname but is '-a-host-name-that-starts-with--' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = true a host name with a component too long validateJSON() fails 1`] = `"should be formatted as hostname but is 'a-vvvvvvvvvvvvvvvveeeeeeeeeeeeeeeerrrrrrrrrrrrrrrryyyyyyyyyyyyyyyy-long-host-name-component' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = true contains underscore validateJSON() fails 1`] = `"should be formatted as hostname but is 'host_name' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = true ends with hyphen validateJSON() fails 1`] = `"should be formatted as hostname but is 'hostname-' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = true ends with underscore validateJSON() fails 1`] = `"should be formatted as hostname but is 'hostname_' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = true exceeds maximum label length validateJSON() fails 1`] = `"should be formatted as hostname but is 'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijkl.com' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = true starts with hyphen validateJSON() fails 1`] = `"should be formatted as hostname but is '-hostname' instead"`;

exports[`tests/draft2020-12/optional/format/hostname.json validation of host names outputFormat = verbose, failFast = true starts with underscore validateJSON() fails 1`] = `"should be formatted as hostname but is '_hostname' instead"`;

exports[`tests/draft2020-12/optional/format/idn-email.json validation of an internationalized e-mail addresses outputFormat = verbose, failFast = false an invalid e-mail address validateJSON() fails 1`] = `"should be formatted as idn-email but is '2962' instead"`;

exports[`tests/draft2020-12/optional/format/idn-email.json validation of an internationalized e-mail addresses outputFormat = verbose, failFast = false an invalid idn e-mail address validateJSON() fails 1`] = `"should be formatted as idn-email but is '2962' instead"`;

exports[`tests/draft2020-12/optional/format/idn-email.json validation of an internationalized e-mail addresses outputFormat = verbose, failFast = true an invalid e-mail address validateJSON() fails 1`] = `"should be formatted as idn-email but is '2962' instead"`;

exports[`tests/draft2020-12/optional/format/idn-email.json validation of an internationalized e-mail addresses outputFormat = verbose, failFast = true an invalid idn e-mail address validateJSON() fails 1`] = `"should be formatted as idn-email but is '2962' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = false an IP address as an integer (decimal) validateJSON() fails 1`] = `"should be formatted as ipv4 but is '2130706433' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = false an IP address as an integer validateJSON() fails 1`] = `"should be formatted as ipv4 but is '0x7f000001' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = false an IP address with out-of-range values validateJSON() fails 1`] = `"should be formatted as ipv4 but is '256.256.256.256' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = false an IP address with too many components validateJSON() fails 1`] = `"should be formatted as ipv4 but is '127.0.0.0.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = false an IP address without 4 components validateJSON() fails 1`] = `"should be formatted as ipv4 but is '127.0' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = false invalid leading zeroes, as they are treated as octals validateJSON() fails 1`] = `"should be formatted as ipv4 but is '087.10.0.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = false invalid non-ASCII '২' (a Bengali 2) validateJSON() fails 1`] = `"should be formatted as ipv4 but is '1২7.0.0.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = true an IP address as an integer (decimal) validateJSON() fails 1`] = `"should be formatted as ipv4 but is '2130706433' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = true an IP address as an integer validateJSON() fails 1`] = `"should be formatted as ipv4 but is '0x7f000001' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = true an IP address with out-of-range values validateJSON() fails 1`] = `"should be formatted as ipv4 but is '256.256.256.256' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = true an IP address with too many components validateJSON() fails 1`] = `"should be formatted as ipv4 but is '127.0.0.0.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = true an IP address without 4 components validateJSON() fails 1`] = `"should be formatted as ipv4 but is '127.0' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = true invalid leading zeroes, as they are treated as octals validateJSON() fails 1`] = `"should be formatted as ipv4 but is '087.10.0.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv4.json validation of IP addresses outputFormat = verbose, failFast = true invalid non-ASCII '২' (a Bengali 2) validateJSON() fails 1`] = `"should be formatted as ipv4 but is '1২7.0.0.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false a long invalid ipv6, below length limit, first validateJSON() fails 1`] = `"should be formatted as ipv6 but is '100:100:100:100:100:100:255.255.255.255.255' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false a long invalid ipv6, below length limit, second validateJSON() fails 1`] = `"should be formatted as ipv6 but is '100:100:100:100:100:100:100:255.255.255.255' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false an IPv6 address containing illegal characters validateJSON() fails 1`] = `"should be formatted as ipv6 but is '::laptop' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false an IPv6 address with out-of-range values validateJSON() fails 1`] = `"should be formatted as ipv6 but is '12345::' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false an IPv6 address with too many components validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false insufficient octets without double colons validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:2:3:4:5:6:7' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false invalid non-ASCII '৪' (a Bengali 4) in the IPv4 portion validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:2::192.16৪.0.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false invalid non-ASCII '৪' (a Bengali 4) validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:2:3:4:5:6:7:৪' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false ipv4 is not ipv6 validateJSON() fails 1`] = `"should be formatted as ipv6 but is '127.0.0.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false ipv4 segment must have 4 octets validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:2:3:4:1.2.3' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false leading whitespace is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '  ::1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false missing leading octet is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is ':2:3:4:5:6:7:8' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false missing leading octet with omitted octets later validateJSON() fails 1`] = `"should be formatted as ipv6 but is ':2:3:4::8' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false missing trailing octet is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:2:3:4:5:6:7:' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false mixed format with ipv4 section with a hex octet validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1::2:192.168.ff.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false mixed format with ipv4 section with octet out of range validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1::2:192.168.256.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false netmask is not a part of ipv6 address validateJSON() fails 1`] = `"should be formatted as ipv6 but is 'fe80::/64' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false no colons is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false trailing 5 hex symbols is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '::abcef' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false trailing whitespace is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '::1  ' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false triple colons is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:2:3:4:5:::8' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false two sets of double colons is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1::d6::42' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = false zone id is not a part of ipv6 address validateJSON() fails 1`] = `"should be formatted as ipv6 but is 'fe80::a%eth1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true a long invalid ipv6, below length limit, first validateJSON() fails 1`] = `"should be formatted as ipv6 but is '100:100:100:100:100:100:255.255.255.255.255' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true a long invalid ipv6, below length limit, second validateJSON() fails 1`] = `"should be formatted as ipv6 but is '100:100:100:100:100:100:100:255.255.255.255' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true an IPv6 address containing illegal characters validateJSON() fails 1`] = `"should be formatted as ipv6 but is '::laptop' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true an IPv6 address with out-of-range values validateJSON() fails 1`] = `"should be formatted as ipv6 but is '12345::' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true an IPv6 address with too many components validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true insufficient octets without double colons validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:2:3:4:5:6:7' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true invalid non-ASCII '৪' (a Bengali 4) in the IPv4 portion validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:2::192.16৪.0.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true invalid non-ASCII '৪' (a Bengali 4) validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:2:3:4:5:6:7:৪' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true ipv4 is not ipv6 validateJSON() fails 1`] = `"should be formatted as ipv6 but is '127.0.0.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true ipv4 segment must have 4 octets validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:2:3:4:1.2.3' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true leading whitespace is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '  ::1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true missing leading octet is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is ':2:3:4:5:6:7:8' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true missing leading octet with omitted octets later validateJSON() fails 1`] = `"should be formatted as ipv6 but is ':2:3:4::8' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true missing trailing octet is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:2:3:4:5:6:7:' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true mixed format with ipv4 section with a hex octet validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1::2:192.168.ff.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true mixed format with ipv4 section with octet out of range validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1::2:192.168.256.1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true netmask is not a part of ipv6 address validateJSON() fails 1`] = `"should be formatted as ipv6 but is 'fe80::/64' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true no colons is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true trailing 5 hex symbols is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '::abcef' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true trailing whitespace is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '::1  ' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true triple colons is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1:2:3:4:5:::8' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true two sets of double colons is invalid validateJSON() fails 1`] = `"should be formatted as ipv6 but is '1::d6::42' instead"`;

exports[`tests/draft2020-12/optional/format/ipv6.json validation of IPv6 addresses outputFormat = verbose, failFast = true zone id is not a part of ipv6 address validateJSON() fails 1`] = `"should be formatted as ipv6 but is 'fe80::a%eth1' instead"`;

exports[`tests/draft2020-12/optional/format/iri.json validation of IRIs outputFormat = verbose, failFast = false an invalid IRI based on IPv6 validateJSON() fails 1`] = `"should be formatted as iri but is 'http://2001:0db8:85a3:0000:0000:8a2e:0370:7334' instead"`;

exports[`tests/draft2020-12/optional/format/iri.json validation of IRIs outputFormat = verbose, failFast = false an invalid IRI though valid IRI reference validateJSON() fails 1`] = `"should be formatted as iri but is 'âππ' instead"`;

exports[`tests/draft2020-12/optional/format/iri.json validation of IRIs outputFormat = verbose, failFast = false an invalid IRI validateJSON() fails 1`] = `"should be formatted as iri but is '\\\\WINDOWS\\filëßåré' instead"`;

exports[`tests/draft2020-12/optional/format/iri.json validation of IRIs outputFormat = verbose, failFast = false an invalid relative IRI Reference validateJSON() fails 1`] = `"should be formatted as iri but is '/abc' instead"`;

exports[`tests/draft2020-12/optional/format/iri.json validation of IRIs outputFormat = verbose, failFast = true an invalid IRI based on IPv6 validateJSON() fails 1`] = `"should be formatted as iri but is 'http://2001:0db8:85a3:0000:0000:8a2e:0370:7334' instead"`;

exports[`tests/draft2020-12/optional/format/iri.json validation of IRIs outputFormat = verbose, failFast = true an invalid IRI though valid IRI reference validateJSON() fails 1`] = `"should be formatted as iri but is 'âππ' instead"`;

exports[`tests/draft2020-12/optional/format/iri.json validation of IRIs outputFormat = verbose, failFast = true an invalid IRI validateJSON() fails 1`] = `"should be formatted as iri but is '\\\\WINDOWS\\filëßåré' instead"`;

exports[`tests/draft2020-12/optional/format/iri.json validation of IRIs outputFormat = verbose, failFast = true an invalid relative IRI Reference validateJSON() fails 1`] = `"should be formatted as iri but is '/abc' instead"`;

exports[`tests/draft2020-12/optional/format/iri-reference.json validation of IRI References outputFormat = verbose, failFast = false an invalid IRI Reference validateJSON() fails 1`] = `"should be formatted as iri-reference but is '\\\\WINDOWS\\filëßåré' instead"`;

exports[`tests/draft2020-12/optional/format/iri-reference.json validation of IRI References outputFormat = verbose, failFast = false an invalid IRI fragment validateJSON() fails 1`] = `"should be formatted as iri-reference but is '#ƒräg\\mênt' instead"`;

exports[`tests/draft2020-12/optional/format/iri-reference.json validation of IRI References outputFormat = verbose, failFast = true an invalid IRI Reference validateJSON() fails 1`] = `"should be formatted as iri-reference but is '\\\\WINDOWS\\filëßåré' instead"`;

exports[`tests/draft2020-12/optional/format/iri-reference.json validation of IRI References outputFormat = verbose, failFast = true an invalid IRI fragment validateJSON() fails 1`] = `"should be formatted as iri-reference but is '#ƒräg\\mênt' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = false not a valid JSON-pointer (~ not escaped) validateJSON() fails 1`] = `"should be formatted as json-pointer but is '/foo/bar~' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = false not a valid JSON-pointer (URI Fragment Identifier) #1 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '#' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = false not a valid JSON-pointer (URI Fragment Identifier) #2 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '#/' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = false not a valid JSON-pointer (URI Fragment Identifier) #3 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '#a' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = false not a valid JSON-pointer (isn't empty nor starts with /) #1 validateJSON() fails 1`] = `"should be formatted as json-pointer but is 'a' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = false not a valid JSON-pointer (isn't empty nor starts with /) #2 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '0' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = false not a valid JSON-pointer (isn't empty nor starts with /) #3 validateJSON() fails 1`] = `"should be formatted as json-pointer but is 'a/a' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = false not a valid JSON-pointer (multiple characters not escaped) validateJSON() fails 1`] = `"should be formatted as json-pointer but is '/~~' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = false not a valid JSON-pointer (some escaped, but not all) #1 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '/~0~' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = false not a valid JSON-pointer (some escaped, but not all) #2 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '/~0/~' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = false not a valid JSON-pointer (wrong escape character) #1 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '/~2' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = false not a valid JSON-pointer (wrong escape character) #2 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '/~-1' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = true not a valid JSON-pointer (~ not escaped) validateJSON() fails 1`] = `"should be formatted as json-pointer but is '/foo/bar~' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = true not a valid JSON-pointer (URI Fragment Identifier) #1 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '#' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = true not a valid JSON-pointer (URI Fragment Identifier) #2 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '#/' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = true not a valid JSON-pointer (URI Fragment Identifier) #3 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '#a' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = true not a valid JSON-pointer (isn't empty nor starts with /) #1 validateJSON() fails 1`] = `"should be formatted as json-pointer but is 'a' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = true not a valid JSON-pointer (isn't empty nor starts with /) #2 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '0' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = true not a valid JSON-pointer (isn't empty nor starts with /) #3 validateJSON() fails 1`] = `"should be formatted as json-pointer but is 'a/a' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = true not a valid JSON-pointer (multiple characters not escaped) validateJSON() fails 1`] = `"should be formatted as json-pointer but is '/~~' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = true not a valid JSON-pointer (some escaped, but not all) #1 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '/~0~' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = true not a valid JSON-pointer (some escaped, but not all) #2 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '/~0/~' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = true not a valid JSON-pointer (wrong escape character) #1 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '/~2' instead"`;

exports[`tests/draft2020-12/optional/format/json-pointer.json validation of JSON-pointers (JSON String Representation) outputFormat = verbose, failFast = true not a valid JSON-pointer (wrong escape character) #2 validateJSON() fails 1`] = `"should be formatted as json-pointer but is '/~-1' instead"`;

exports[`tests/draft2020-12/optional/format/regex.json validation of regular expressions outputFormat = verbose, failFast = false a regular expression with unclosed parens is invalid validateJSON() fails 1`] = `"should be formatted as regex but is '^(abc]' instead"`;

exports[`tests/draft2020-12/optional/format/regex.json validation of regular expressions outputFormat = verbose, failFast = true a regular expression with unclosed parens is invalid validateJSON() fails 1`] = `"should be formatted as regex but is '^(abc]' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = false ## is not a valid json-pointer validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '0##' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = false an invalid RJP that is a valid JSON Pointer validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '/foo/bar' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = false empty string validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = false explicit positive prefix validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '+1/foo/bar' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = false negative prefix validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '-1/foo/bar' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = false zero cannot be followed by other digits, plus json-pointer validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '01/a' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = false zero cannot be followed by other digits, plus octothorpe validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '01#' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = true ## is not a valid json-pointer validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '0##' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = true an invalid RJP that is a valid JSON Pointer validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '/foo/bar' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = true empty string validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = true explicit positive prefix validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '+1/foo/bar' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = true negative prefix validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '-1/foo/bar' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = true zero cannot be followed by other digits, plus json-pointer validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '01/a' instead"`;

exports[`tests/draft2020-12/optional/format/relative-json-pointer.json validation of Relative JSON Pointers (RJP) outputFormat = verbose, failFast = true zero cannot be followed by other digits, plus octothorpe validateJSON() fails 1`] = `"should be formatted as relative-json-pointer but is '01#' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false an invalid offset indicator validateJSON() fails 1`] = `"should be formatted as time but is '08:30:06 PST' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false an invalid time string with invalid hour validateJSON() fails 1`] = `"should be formatted as time but is '24:00:00Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false an invalid time string with invalid leap second (wrong hour) validateJSON() fails 1`] = `"should be formatted as time but is '22:59:60Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false an invalid time string with invalid leap second (wrong minute) validateJSON() fails 1`] = `"should be formatted as time but is '23:58:60Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false an invalid time string with invalid minute validateJSON() fails 1`] = `"should be formatted as time but is '00:60:00Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false an invalid time string with invalid second validateJSON() fails 1`] = `"should be formatted as time but is '00:00:61Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false an invalid time string with invalid time numoffset hour validateJSON() fails 1`] = `"should be formatted as time but is '01:02:03+24:00' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false an invalid time string with invalid time numoffset minute validateJSON() fails 1`] = `"should be formatted as time but is '01:02:03+00:60' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false an invalid time string with invalid time with both Z and numoffset validateJSON() fails 1`] = `"should be formatted as time but is '01:02:03Z+00:30' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false contains letters validateJSON() fails 1`] = `"should be formatted as time but is 'ab:cd:ef' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false hour, minute in time-offset must be two digits validateJSON() fails 1`] = `"should be formatted as time but is '08:30:06-8:000' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false hour, minute, second must be two digits validateJSON() fails 1`] = `"should be formatted as time but is '8:0030:6Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false invalid leap second, Zulu (wrong hour) validateJSON() fails 1`] = `"should be formatted as time but is '22:59:60Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false invalid leap second, Zulu (wrong minute) validateJSON() fails 1`] = `"should be formatted as time but is '23:58:60Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false invalid leap second, negative time-offset (wrong hour) validateJSON() fails 1`] = `"should be formatted as time but is '23:59:60-01:00' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false invalid leap second, negative time-offset (wrong minute) validateJSON() fails 1`] = `"should be formatted as time but is '23:59:60-00:30' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false invalid leap second, positive time-offset (wrong hour) validateJSON() fails 1`] = `"should be formatted as time but is '23:59:60+01:00' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false invalid leap second, positive time-offset (wrong minute) validateJSON() fails 1`] = `"should be formatted as time but is '23:59:60+00:30' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false invalid leap second, zero time-offset (wrong hour) validateJSON() fails 1`] = `"should be formatted as time but is '22:59:60+00:00' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false invalid leap second, zero time-offset (wrong minute) validateJSON() fails 1`] = `"should be formatted as time but is '23:58:60+00:00' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false invalid non-ASCII '২' (a Bengali 2) validateJSON() fails 1`] = `"should be formatted as time but is '1২:00:00Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false invalid time string with extra leading zeros validateJSON() fails 1`] = `"should be formatted as time but is '008:030:006Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false invalid time string with no leading zero for single digit validateJSON() fails 1`] = `"should be formatted as time but is '8:3:6Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false no time offset validateJSON() fails 1`] = `"should be formatted as time but is '12:00:00' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false no time offset with second fraction validateJSON() fails 1`] = `"should be formatted as time but is '12:00:00.52' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false offset not starting with plus or minus validateJSON() fails 1`] = `"should be formatted as time but is '08:30:06#00:20' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = false only RFC3339 not all of ISO 8601 are valid validateJSON() fails 1`] = `"should be formatted as time but is '01:01:01,1111' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true an invalid offset indicator validateJSON() fails 1`] = `"should be formatted as time but is '08:30:06 PST' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true an invalid time string with invalid hour validateJSON() fails 1`] = `"should be formatted as time but is '24:00:00Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true an invalid time string with invalid leap second (wrong hour) validateJSON() fails 1`] = `"should be formatted as time but is '22:59:60Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true an invalid time string with invalid leap second (wrong minute) validateJSON() fails 1`] = `"should be formatted as time but is '23:58:60Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true an invalid time string with invalid minute validateJSON() fails 1`] = `"should be formatted as time but is '00:60:00Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true an invalid time string with invalid second validateJSON() fails 1`] = `"should be formatted as time but is '00:00:61Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true an invalid time string with invalid time numoffset hour validateJSON() fails 1`] = `"should be formatted as time but is '01:02:03+24:00' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true an invalid time string with invalid time numoffset minute validateJSON() fails 1`] = `"should be formatted as time but is '01:02:03+00:60' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true an invalid time string with invalid time with both Z and numoffset validateJSON() fails 1`] = `"should be formatted as time but is '01:02:03Z+00:30' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true contains letters validateJSON() fails 1`] = `"should be formatted as time but is 'ab:cd:ef' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true hour, minute in time-offset must be two digits validateJSON() fails 1`] = `"should be formatted as time but is '08:30:06-8:000' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true hour, minute, second must be two digits validateJSON() fails 1`] = `"should be formatted as time but is '8:0030:6Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true invalid leap second, Zulu (wrong hour) validateJSON() fails 1`] = `"should be formatted as time but is '22:59:60Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true invalid leap second, Zulu (wrong minute) validateJSON() fails 1`] = `"should be formatted as time but is '23:58:60Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true invalid leap second, negative time-offset (wrong hour) validateJSON() fails 1`] = `"should be formatted as time but is '23:59:60-01:00' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true invalid leap second, negative time-offset (wrong minute) validateJSON() fails 1`] = `"should be formatted as time but is '23:59:60-00:30' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true invalid leap second, positive time-offset (wrong hour) validateJSON() fails 1`] = `"should be formatted as time but is '23:59:60+01:00' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true invalid leap second, positive time-offset (wrong minute) validateJSON() fails 1`] = `"should be formatted as time but is '23:59:60+00:30' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true invalid leap second, zero time-offset (wrong hour) validateJSON() fails 1`] = `"should be formatted as time but is '22:59:60+00:00' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true invalid leap second, zero time-offset (wrong minute) validateJSON() fails 1`] = `"should be formatted as time but is '23:58:60+00:00' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true invalid non-ASCII '২' (a Bengali 2) validateJSON() fails 1`] = `"should be formatted as time but is '1২:00:00Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true invalid time string with extra leading zeros validateJSON() fails 1`] = `"should be formatted as time but is '008:030:006Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true invalid time string with no leading zero for single digit validateJSON() fails 1`] = `"should be formatted as time but is '8:3:6Z' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true no time offset validateJSON() fails 1`] = `"should be formatted as time but is '12:00:00' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true no time offset with second fraction validateJSON() fails 1`] = `"should be formatted as time but is '12:00:00.52' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true offset not starting with plus or minus validateJSON() fails 1`] = `"should be formatted as time but is '08:30:06#00:20' instead"`;

exports[`tests/draft2020-12/optional/format/time.json validation of time strings outputFormat = verbose, failFast = true only RFC3339 not all of ISO 8601 are valid validateJSON() fails 1`] = `"should be formatted as time but is '01:01:01,1111' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = false an invalid URI though valid URI reference validateJSON() fails 1`] = `"should be formatted as uri but is 'abc' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = false an invalid URI validateJSON() fails 1`] = `"should be formatted as uri but is '\\\\WINDOWS\\fileshare' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = false an invalid URI with comma in scheme validateJSON() fails 1`] = `"should be formatted as uri but is 'bar,baz:foo' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = false an invalid URI with spaces and missing scheme validateJSON() fails 1`] = `"should be formatted as uri but is ':// should fail' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = false an invalid URI with spaces validateJSON() fails 1`] = `"should be formatted as uri but is 'http:// shouldfail.com' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = false an invalid protocol-relative URI Reference validateJSON() fails 1`] = `"should be formatted as uri but is '//foo.bar/?baz=qux#quux' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = false an invalid relative URI Reference validateJSON() fails 1`] = `"should be formatted as uri but is '/abc' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = true an invalid URI though valid URI reference validateJSON() fails 1`] = `"should be formatted as uri but is 'abc' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = true an invalid URI validateJSON() fails 1`] = `"should be formatted as uri but is '\\\\WINDOWS\\fileshare' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = true an invalid URI with comma in scheme validateJSON() fails 1`] = `"should be formatted as uri but is 'bar,baz:foo' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = true an invalid URI with spaces and missing scheme validateJSON() fails 1`] = `"should be formatted as uri but is ':// should fail' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = true an invalid URI with spaces validateJSON() fails 1`] = `"should be formatted as uri but is 'http:// shouldfail.com' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = true an invalid protocol-relative URI Reference validateJSON() fails 1`] = `"should be formatted as uri but is '//foo.bar/?baz=qux#quux' instead"`;

exports[`tests/draft2020-12/optional/format/uri.json validation of URIs outputFormat = verbose, failFast = true an invalid relative URI Reference validateJSON() fails 1`] = `"should be formatted as uri but is '/abc' instead"`;

exports[`tests/draft2020-12/optional/format/uri-reference.json validation of URI References outputFormat = verbose, failFast = false an invalid URI Reference validateJSON() fails 1`] = `"should be formatted as uri-reference but is '\\\\WINDOWS\\fileshare' instead"`;

exports[`tests/draft2020-12/optional/format/uri-reference.json validation of URI References outputFormat = verbose, failFast = false an invalid URI fragment validateJSON() fails 1`] = `"should be formatted as uri-reference but is '#frag\\ment' instead"`;

exports[`tests/draft2020-12/optional/format/uri-reference.json validation of URI References outputFormat = verbose, failFast = true an invalid URI Reference validateJSON() fails 1`] = `"should be formatted as uri-reference but is '\\\\WINDOWS\\fileshare' instead"`;

exports[`tests/draft2020-12/optional/format/uri-reference.json validation of URI References outputFormat = verbose, failFast = true an invalid URI fragment validateJSON() fails 1`] = `"should be formatted as uri-reference but is '#frag\\ment' instead"`;

exports[`tests/draft2020-12/optional/format/uri-template.json format: uri-template outputFormat = verbose, failFast = false an invalid uri-template validateJSON() fails 1`] = `"should be formatted as uri-template but is 'http://example.com/dictionary/{term:1}/{term' instead"`;

exports[`tests/draft2020-12/optional/format/uri-template.json format: uri-template outputFormat = verbose, failFast = true an invalid uri-template validateJSON() fails 1`] = `"should be formatted as uri-template but is 'http://example.com/dictionary/{term:1}/{term' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = false bad characters (not hex) validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8aa08-aa98-11ea-b4ga-73b441d16380' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = false dashes in the wrong spot validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8aa08aa9811eab4aa73b441d16380----' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = false missing section validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8aa08-aa98-11ea-73b441d16380' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = false no dashes validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8aa08aa9811eab4aa73b441d16380' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = false too few dashes validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8aa08aa98-11ea-b4aa73b441d16380' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = false too many dashes validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8-aa08-aa98-11ea-b4aa73b44-1d16380' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = false wrong length validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8aa08-aa98-11ea-b4aa-73b441d1638' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = true bad characters (not hex) validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8aa08-aa98-11ea-b4ga-73b441d16380' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = true dashes in the wrong spot validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8aa08aa9811eab4aa73b441d16380----' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = true missing section validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8aa08-aa98-11ea-73b441d16380' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = true no dashes validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8aa08aa9811eab4aa73b441d16380' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = true too few dashes validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8aa08aa98-11ea-b4aa73b441d16380' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = true too many dashes validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8-aa08-aa98-11ea-b4aa73b44-1d16380' instead"`;

exports[`tests/draft2020-12/optional/format/uuid.json uuid format outputFormat = verbose, failFast = true wrong length validateJSON() fails 1`] = `"should be formatted as uuid but is '2eb8aa08-aa98-11ea-b4aa-73b441d1638' instead"`;
