// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`tests/draft2020-12/additionalProperties.json additionalProperties being false does not allow other properties outputFormat = verbose, failFast = false an additional property is invalid validateJSON() fails 1`] = `"has an invalid property quux"`;

exports[`tests/draft2020-12/additionalProperties.json additionalProperties being false does not allow other properties outputFormat = verbose, failFast = true an additional property is invalid validateJSON() fails 1`] = `"has a disallowed additional property ('quux')"`;

exports[`tests/draft2020-12/additionalProperties.json additionalProperties can exist by itself outputFormat = verbose, failFast = false an additional invalid property is invalid validateJSON() fails 1`] = `"has an invalid property foo (should be a boolean but is an integer instead)"`;

exports[`tests/draft2020-12/additionalProperties.json additionalProperties can exist by itself outputFormat = verbose, failFast = true an additional invalid property is invalid validateJSON() fails 1`] = `"has an invalid property foo (should be a boolean but is an integer instead)"`;

exports[`tests/draft2020-12/additionalProperties.json additionalProperties does not look in applicators outputFormat = verbose, failFast = false properties defined in allOf are not examined validateJSON() fails 1`] = `"has an invalid property foo (should be a boolean but is an integer instead)"`;

exports[`tests/draft2020-12/additionalProperties.json additionalProperties does not look in applicators outputFormat = verbose, failFast = true properties defined in allOf are not examined validateJSON() fails 1`] = `"has an invalid property foo (should be a boolean but is an integer instead)"`;

exports[`tests/draft2020-12/additionalProperties.json additionalProperties with schema outputFormat = verbose, failFast = false an additional invalid property is invalid validateJSON() fails 1`] = `"has an invalid property quux (should be a boolean but is an integer instead)"`;

exports[`tests/draft2020-12/additionalProperties.json additionalProperties with schema outputFormat = verbose, failFast = true an additional invalid property is invalid validateJSON() fails 1`] = `"has an invalid property quux (should be a boolean but is an integer instead)"`;

exports[`tests/draft2020-12/additionalProperties.json non-ASCII pattern with additionalProperties outputFormat = verbose, failFast = false not matching the pattern is invalid validateJSON() fails 1`] = `"has an invalid property élmény"`;

exports[`tests/draft2020-12/additionalProperties.json non-ASCII pattern with additionalProperties outputFormat = verbose, failFast = true not matching the pattern is invalid validateJSON() fails 1`] = `"has a disallowed additional property ('élmény')"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = false allOf: false, anyOf: false, oneOf: false validateJSON() fails 1`] = `"should be a multiple of 2 but is 1 instead; does not validate against any subschema; should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = false allOf: false, anyOf: false, oneOf: true validateJSON() fails 1`] = `"should be a multiple of 2 but is 5 instead; does not validate against any subschema"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = false allOf: false, anyOf: true, oneOf: false validateJSON() fails 1`] = `"should be a multiple of 2 but is 3 instead; should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = false allOf: false, anyOf: true, oneOf: true validateJSON() fails 1`] = `"should be a multiple of 2 but is 15 instead"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = false allOf: true, anyOf: false, oneOf: false validateJSON() fails 1`] = `"does not validate against any subschema; should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = false allOf: true, anyOf: false, oneOf: true validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = false allOf: true, anyOf: true, oneOf: false validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = true allOf: false, anyOf: false, oneOf: false validateJSON() fails 1`] = `"should be a multiple of 2 but is 1 instead"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = true allOf: false, anyOf: false, oneOf: true validateJSON() fails 1`] = `"should be a multiple of 2 but is 5 instead"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = true allOf: false, anyOf: true, oneOf: false validateJSON() fails 1`] = `"should be a multiple of 2 but is 3 instead"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = true allOf: false, anyOf: true, oneOf: true validateJSON() fails 1`] = `"should be a multiple of 2 but is 15 instead"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = true allOf: true, anyOf: false, oneOf: false validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = true allOf: true, anyOf: false, oneOf: true validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/allOf.json allOf combined with anyOf, oneOf outputFormat = verbose, failFast = true allOf: true, anyOf: true, oneOf: false validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/allOf.json allOf outputFormat = verbose, failFast = false mismatch first validateJSON() fails 1`] = `"is missing 'foo'"`;

exports[`tests/draft2020-12/allOf.json allOf outputFormat = verbose, failFast = false mismatch second validateJSON() fails 1`] = `"is missing 'bar'"`;

exports[`tests/draft2020-12/allOf.json allOf outputFormat = verbose, failFast = false wrong type validateJSON() fails 1`] = `"has an invalid property bar (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/allOf.json allOf outputFormat = verbose, failFast = true mismatch first validateJSON() fails 1`] = `"is missing 'foo'"`;

exports[`tests/draft2020-12/allOf.json allOf outputFormat = verbose, failFast = true mismatch second validateJSON() fails 1`] = `"is missing 'bar'"`;

exports[`tests/draft2020-12/allOf.json allOf outputFormat = verbose, failFast = true wrong type validateJSON() fails 1`] = `"has an invalid property (bar should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/allOf.json allOf simple types outputFormat = verbose, failFast = false mismatch one validateJSON() fails 1`] = `"should be less than or equal to 30 but is 35 instead"`;

exports[`tests/draft2020-12/allOf.json allOf simple types outputFormat = verbose, failFast = true mismatch one validateJSON() fails 1`] = `"should be less than or equal to 30 but is 35 instead"`;

exports[`tests/draft2020-12/allOf.json allOf with base schema outputFormat = verbose, failFast = false mismatch base schema validateJSON() fails 1`] = `"is missing 'bar'"`;

exports[`tests/draft2020-12/allOf.json allOf with base schema outputFormat = verbose, failFast = false mismatch both validateJSON() fails 1`] = `"is missing 'foo' and is missing 'baz'"`;

exports[`tests/draft2020-12/allOf.json allOf with base schema outputFormat = verbose, failFast = false mismatch first allOf validateJSON() fails 1`] = `"is missing 'foo'"`;

exports[`tests/draft2020-12/allOf.json allOf with base schema outputFormat = verbose, failFast = false mismatch second allOf validateJSON() fails 1`] = `"is missing 'baz'"`;

exports[`tests/draft2020-12/allOf.json allOf with base schema outputFormat = verbose, failFast = true mismatch base schema validateJSON() fails 1`] = `"is missing 'bar'"`;

exports[`tests/draft2020-12/allOf.json allOf with base schema outputFormat = verbose, failFast = true mismatch both validateJSON() fails 1`] = `"is missing 'foo'"`;

exports[`tests/draft2020-12/allOf.json allOf with base schema outputFormat = verbose, failFast = true mismatch first allOf validateJSON() fails 1`] = `"is missing 'foo'"`;

exports[`tests/draft2020-12/allOf.json allOf with base schema outputFormat = verbose, failFast = true mismatch second allOf validateJSON() fails 1`] = `"is missing 'baz'"`;

exports[`tests/draft2020-12/allOf.json allOf with boolean schemas, all false outputFormat = verbose, failFast = false any value is invalid validateJSON() fails 1`] = `"should not be defined but is 'foo' and should not be defined but is 'foo'"`;

exports[`tests/draft2020-12/allOf.json allOf with boolean schemas, all false outputFormat = verbose, failFast = true any value is invalid validateJSON() fails 1`] = `"should not be defined but is 'foo'"`;

exports[`tests/draft2020-12/allOf.json allOf with boolean schemas, some false outputFormat = verbose, failFast = false any value is invalid validateJSON() fails 1`] = `"should not be defined but is 'foo'"`;

exports[`tests/draft2020-12/allOf.json allOf with boolean schemas, some false outputFormat = verbose, failFast = true any value is invalid validateJSON() fails 1`] = `"should not be defined but is 'foo'"`;

exports[`tests/draft2020-12/allOf.json allOf with the first empty schema outputFormat = verbose, failFast = false string is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/allOf.json allOf with the first empty schema outputFormat = verbose, failFast = true string is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/allOf.json allOf with the last empty schema outputFormat = verbose, failFast = false string is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/allOf.json allOf with the last empty schema outputFormat = verbose, failFast = true string is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/allOf.json nested allOf, to check validation semantics outputFormat = verbose, failFast = false anything non-null is invalid validateJSON() fails 1`] = `"should be null but is an integer instead"`;

exports[`tests/draft2020-12/allOf.json nested allOf, to check validation semantics outputFormat = verbose, failFast = true anything non-null is invalid validateJSON() fails 1`] = `"should be null but is an integer instead"`;

exports[`tests/draft2020-12/anchor.json $anchor inside an enum is not a real identifier outputFormat = verbose, failFast = false in implementations that strip $anchor, this may match either $def validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anchor.json $anchor inside an enum is not a real identifier outputFormat = verbose, failFast = false no match on enum or $ref to $anchor validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anchor.json $anchor inside an enum is not a real identifier outputFormat = verbose, failFast = true in implementations that strip $anchor, this may match either $def validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anchor.json $anchor inside an enum is not a real identifier outputFormat = verbose, failFast = true no match on enum or $ref to $anchor validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anchor.json Location-independent identifier outputFormat = verbose, failFast = false mismatch validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/anchor.json Location-independent identifier outputFormat = verbose, failFast = true mismatch validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/anchor.json Location-independent identifier with absolute URI outputFormat = verbose, failFast = false mismatch validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/anchor.json Location-independent identifier with absolute URI outputFormat = verbose, failFast = true mismatch validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/anchor.json Location-independent identifier with base URI change in subschema outputFormat = verbose, failFast = false mismatch validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/anchor.json Location-independent identifier with base URI change in subschema outputFormat = verbose, failFast = true mismatch validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/anchor.json invalid anchors outputFormat = verbose, failFast = false JSON pointers are not valid validateJSON() fails 1`] = `"has an invalid property $anchor (should match '^[A-Za-z_][-A-Za-z0-9._]*$' but is '/a/b' instead)"`;

exports[`tests/draft2020-12/anchor.json invalid anchors outputFormat = verbose, failFast = false MUST start with a letter (and not #) validateJSON() fails 1`] = `"has an invalid property $anchor (should match '^[A-Za-z_][-A-Za-z0-9._]*$' but is '#foo' instead)"`;

exports[`tests/draft2020-12/anchor.json invalid anchors outputFormat = verbose, failFast = false invalid with valid beginning validateJSON() fails 1`] = `"has an invalid property $anchor (should match '^[A-Za-z_][-A-Za-z0-9._]*$' but is 'foo#something' instead)"`;

exports[`tests/draft2020-12/anchor.json invalid anchors outputFormat = verbose, failFast = true JSON pointers are not valid validateJSON() fails 1`] = `"has an invalid property ($anchor should match '^[A-Za-z_][-A-Za-z0-9._]*$' but is '/a/b' instead)"`;

exports[`tests/draft2020-12/anchor.json invalid anchors outputFormat = verbose, failFast = true MUST start with a letter (and not #) validateJSON() fails 1`] = `"has an invalid property ($anchor should match '^[A-Za-z_][-A-Za-z0-9._]*$' but is '#foo' instead)"`;

exports[`tests/draft2020-12/anchor.json invalid anchors outputFormat = verbose, failFast = true invalid with valid beginning validateJSON() fails 1`] = `"has an invalid property ($anchor should match '^[A-Za-z_][-A-Za-z0-9._]*$' but is 'foo#something' instead)"`;

exports[`tests/draft2020-12/anchor.json non-schema object containing an $anchor property outputFormat = verbose, failFast = false const at const_not_anchor does not match validateJSON() fails 1`] = `"should be {"$anchor":"not_a_real_anchor"} but is 1 instead"`;

exports[`tests/draft2020-12/anchor.json non-schema object containing an $anchor property outputFormat = verbose, failFast = true const at const_not_anchor does not match validateJSON() fails 1`] = `"should be {"$anchor":"not_a_real_anchor"} but is 1 instead"`;

exports[`tests/draft2020-12/anchor.json same $anchor with different base uri outputFormat = verbose, failFast = false $ref does not resolve to /$defs/A/allOf/0 validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/anchor.json same $anchor with different base uri outputFormat = verbose, failFast = true $ref does not resolve to /$defs/A/allOf/0 validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/anyOf.json anyOf complex types outputFormat = verbose, failFast = false neither anyOf valid (complex) validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anyOf.json anyOf complex types outputFormat = verbose, failFast = true neither anyOf valid (complex) validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anyOf.json anyOf outputFormat = verbose, failFast = false neither anyOf valid validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anyOf.json anyOf outputFormat = verbose, failFast = true neither anyOf valid validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anyOf.json anyOf with base schema outputFormat = verbose, failFast = false both anyOf invalid validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anyOf.json anyOf with base schema outputFormat = verbose, failFast = false mismatch base schema validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/anyOf.json anyOf with base schema outputFormat = verbose, failFast = true both anyOf invalid validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anyOf.json anyOf with base schema outputFormat = verbose, failFast = true mismatch base schema validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/anyOf.json anyOf with boolean schemas, all false outputFormat = verbose, failFast = false any value is invalid validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anyOf.json anyOf with boolean schemas, all false outputFormat = verbose, failFast = true any value is invalid validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anyOf.json nested anyOf, to check validation semantics outputFormat = verbose, failFast = false anything non-null is invalid validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/anyOf.json nested anyOf, to check validation semantics outputFormat = verbose, failFast = true anything non-null is invalid validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = false array is invalid validateJSON() fails 1`] = `"should not be defined but is ["foo"]"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = false boolean false is invalid validateJSON() fails 1`] = `"should not be defined but is false"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = false boolean true is invalid validateJSON() fails 1`] = `"should not be defined but is true"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = false empty array is invalid validateJSON() fails 1`] = `"should not be defined but is []"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = false empty object is invalid validateJSON() fails 1`] = `"should not be defined but is {}"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = false null is invalid validateJSON() fails 1`] = `"should not be defined but is null"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = false number is invalid validateJSON() fails 1`] = `"should not be defined but is 1"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = false object is invalid validateJSON() fails 1`] = `"should not be defined but is {"foo":"bar"}"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = false string is invalid validateJSON() fails 1`] = `"should not be defined but is 'foo'"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = true array is invalid validateJSON() fails 1`] = `"should not be defined but is ["foo"]"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = true boolean false is invalid validateJSON() fails 1`] = `"should not be defined but is false"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = true boolean true is invalid validateJSON() fails 1`] = `"should not be defined but is true"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = true empty array is invalid validateJSON() fails 1`] = `"should not be defined but is []"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = true empty object is invalid validateJSON() fails 1`] = `"should not be defined but is {}"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = true null is invalid validateJSON() fails 1`] = `"should not be defined but is null"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = true number is invalid validateJSON() fails 1`] = `"should not be defined but is 1"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = true object is invalid validateJSON() fails 1`] = `"should not be defined but is {"foo":"bar"}"`;

exports[`tests/draft2020-12/boolean_schema.json boolean schema 'false' outputFormat = verbose, failFast = true string is invalid validateJSON() fails 1`] = `"should not be defined but is 'foo'"`;

exports[`tests/draft2020-12/const.json const validation outputFormat = verbose, failFast = false another type is invalid validateJSON() fails 1`] = `"should be 2 but is 'a' instead"`;

exports[`tests/draft2020-12/const.json const validation outputFormat = verbose, failFast = false another value is invalid validateJSON() fails 1`] = `"should be 2 but is 5 instead"`;

exports[`tests/draft2020-12/const.json const validation outputFormat = verbose, failFast = true another type is invalid validateJSON() fails 1`] = `"should be 2 but is 'a' instead"`;

exports[`tests/draft2020-12/const.json const validation outputFormat = verbose, failFast = true another value is invalid validateJSON() fails 1`] = `"should be 2 but is 5 instead"`;

exports[`tests/draft2020-12/const.json const with [false] does not match [0] outputFormat = verbose, failFast = false [0.0] is invalid validateJSON() fails 1`] = `"should be [false] but is [0] instead"`;

exports[`tests/draft2020-12/const.json const with [false] does not match [0] outputFormat = verbose, failFast = false [0] is invalid validateJSON() fails 1`] = `"should be [false] but is [0] instead"`;

exports[`tests/draft2020-12/const.json const with [false] does not match [0] outputFormat = verbose, failFast = true [0.0] is invalid validateJSON() fails 1`] = `"should be [false] but is [0] instead"`;

exports[`tests/draft2020-12/const.json const with [false] does not match [0] outputFormat = verbose, failFast = true [0] is invalid validateJSON() fails 1`] = `"should be [false] but is [0] instead"`;

exports[`tests/draft2020-12/const.json const with [true] does not match [1] outputFormat = verbose, failFast = false [1.0] is invalid validateJSON() fails 1`] = `"should be [true] but is [1] instead"`;

exports[`tests/draft2020-12/const.json const with [true] does not match [1] outputFormat = verbose, failFast = false [1] is invalid validateJSON() fails 1`] = `"should be [true] but is [1] instead"`;

exports[`tests/draft2020-12/const.json const with [true] does not match [1] outputFormat = verbose, failFast = true [1.0] is invalid validateJSON() fails 1`] = `"should be [true] but is [1] instead"`;

exports[`tests/draft2020-12/const.json const with [true] does not match [1] outputFormat = verbose, failFast = true [1] is invalid validateJSON() fails 1`] = `"should be [true] but is [1] instead"`;

exports[`tests/draft2020-12/const.json const with {"a": false} does not match {"a": 0} outputFormat = verbose, failFast = false {"a": 0.0} is invalid validateJSON() fails 1`] = `"should be {"a":false} but is {"a":0} instead"`;

exports[`tests/draft2020-12/const.json const with {"a": false} does not match {"a": 0} outputFormat = verbose, failFast = false {"a": 0} is invalid validateJSON() fails 1`] = `"should be {"a":false} but is {"a":0} instead"`;

exports[`tests/draft2020-12/const.json const with {"a": false} does not match {"a": 0} outputFormat = verbose, failFast = true {"a": 0.0} is invalid validateJSON() fails 1`] = `"should be {"a":false} but is {"a":0} instead"`;

exports[`tests/draft2020-12/const.json const with {"a": false} does not match {"a": 0} outputFormat = verbose, failFast = true {"a": 0} is invalid validateJSON() fails 1`] = `"should be {"a":false} but is {"a":0} instead"`;

exports[`tests/draft2020-12/const.json const with {"a": true} does not match {"a": 1} outputFormat = verbose, failFast = false {"a": 1.0} is invalid validateJSON() fails 1`] = `"should be {"a":true} but is {"a":1} instead"`;

exports[`tests/draft2020-12/const.json const with {"a": true} does not match {"a": 1} outputFormat = verbose, failFast = false {"a": 1} is invalid validateJSON() fails 1`] = `"should be {"a":true} but is {"a":1} instead"`;

exports[`tests/draft2020-12/const.json const with {"a": true} does not match {"a": 1} outputFormat = verbose, failFast = true {"a": 1.0} is invalid validateJSON() fails 1`] = `"should be {"a":true} but is {"a":1} instead"`;

exports[`tests/draft2020-12/const.json const with {"a": true} does not match {"a": 1} outputFormat = verbose, failFast = true {"a": 1} is invalid validateJSON() fails 1`] = `"should be {"a":true} but is {"a":1} instead"`;

exports[`tests/draft2020-12/const.json const with -2.0 matches integer and float types outputFormat = verbose, failFast = false float -2.00001 is invalid validateJSON() fails 1`] = `"should be -2 but is -2.00001 instead"`;

exports[`tests/draft2020-12/const.json const with -2.0 matches integer and float types outputFormat = verbose, failFast = false float 2.0 is invalid validateJSON() fails 1`] = `"should be -2 but is 2 instead"`;

exports[`tests/draft2020-12/const.json const with -2.0 matches integer and float types outputFormat = verbose, failFast = false integer 2 is invalid validateJSON() fails 1`] = `"should be -2 but is 2 instead"`;

exports[`tests/draft2020-12/const.json const with -2.0 matches integer and float types outputFormat = verbose, failFast = true float -2.00001 is invalid validateJSON() fails 1`] = `"should be -2 but is -2.00001 instead"`;

exports[`tests/draft2020-12/const.json const with -2.0 matches integer and float types outputFormat = verbose, failFast = true float 2.0 is invalid validateJSON() fails 1`] = `"should be -2 but is 2 instead"`;

exports[`tests/draft2020-12/const.json const with -2.0 matches integer and float types outputFormat = verbose, failFast = true integer 2 is invalid validateJSON() fails 1`] = `"should be -2 but is 2 instead"`;

exports[`tests/draft2020-12/const.json const with 0 does not match other zero-like types outputFormat = verbose, failFast = false empty array is invalid validateJSON() fails 1`] = `"should be 0 but is [] instead"`;

exports[`tests/draft2020-12/const.json const with 0 does not match other zero-like types outputFormat = verbose, failFast = false empty object is invalid validateJSON() fails 1`] = `"should be 0 but is {} instead"`;

exports[`tests/draft2020-12/const.json const with 0 does not match other zero-like types outputFormat = verbose, failFast = false empty string is invalid validateJSON() fails 1`] = `"should be 0 but is '' instead"`;

exports[`tests/draft2020-12/const.json const with 0 does not match other zero-like types outputFormat = verbose, failFast = false false is invalid validateJSON() fails 1`] = `"should be 0 but is false instead"`;

exports[`tests/draft2020-12/const.json const with 0 does not match other zero-like types outputFormat = verbose, failFast = true empty array is invalid validateJSON() fails 1`] = `"should be 0 but is [] instead"`;

exports[`tests/draft2020-12/const.json const with 0 does not match other zero-like types outputFormat = verbose, failFast = true empty object is invalid validateJSON() fails 1`] = `"should be 0 but is {} instead"`;

exports[`tests/draft2020-12/const.json const with 0 does not match other zero-like types outputFormat = verbose, failFast = true empty string is invalid validateJSON() fails 1`] = `"should be 0 but is '' instead"`;

exports[`tests/draft2020-12/const.json const with 0 does not match other zero-like types outputFormat = verbose, failFast = true false is invalid validateJSON() fails 1`] = `"should be 0 but is false instead"`;

exports[`tests/draft2020-12/const.json const with 1 does not match true outputFormat = verbose, failFast = false true is invalid validateJSON() fails 1`] = `"should be 1 but is true instead"`;

exports[`tests/draft2020-12/const.json const with 1 does not match true outputFormat = verbose, failFast = true true is invalid validateJSON() fails 1`] = `"should be 1 but is true instead"`;

exports[`tests/draft2020-12/const.json const with array outputFormat = verbose, failFast = false another array item is invalid validateJSON() fails 1`] = `"should be [{"foo":"bar"}] but is [2] instead"`;

exports[`tests/draft2020-12/const.json const with array outputFormat = verbose, failFast = false array with additional items is invalid validateJSON() fails 1`] = `"should be [{"foo":"bar"}] but is [1,2,3] instead"`;

exports[`tests/draft2020-12/const.json const with array outputFormat = verbose, failFast = true another array item is invalid validateJSON() fails 1`] = `"should be [{"foo":"bar"}] but is [2] instead"`;

exports[`tests/draft2020-12/const.json const with array outputFormat = verbose, failFast = true array with additional items is invalid validateJSON() fails 1`] = `"should be [{"foo":"bar"}] but is [1,2,3] instead"`;

exports[`tests/draft2020-12/const.json const with false does not match 0 outputFormat = verbose, failFast = false float zero is invalid validateJSON() fails 1`] = `"should be false but is 0 instead"`;

exports[`tests/draft2020-12/const.json const with false does not match 0 outputFormat = verbose, failFast = false integer zero is invalid validateJSON() fails 1`] = `"should be false but is 0 instead"`;

exports[`tests/draft2020-12/const.json const with false does not match 0 outputFormat = verbose, failFast = true float zero is invalid validateJSON() fails 1`] = `"should be false but is 0 instead"`;

exports[`tests/draft2020-12/const.json const with false does not match 0 outputFormat = verbose, failFast = true integer zero is invalid validateJSON() fails 1`] = `"should be false but is 0 instead"`;

exports[`tests/draft2020-12/const.json const with null outputFormat = verbose, failFast = false not null is invalid validateJSON() fails 1`] = `"should be null but is 0 instead"`;

exports[`tests/draft2020-12/const.json const with null outputFormat = verbose, failFast = true not null is invalid validateJSON() fails 1`] = `"should be null but is 0 instead"`;

exports[`tests/draft2020-12/const.json const with object outputFormat = verbose, failFast = false another object is invalid validateJSON() fails 1`] = `"should be {"foo":"bar","baz":"bax"} but is {"foo":"bar"} instead"`;

exports[`tests/draft2020-12/const.json const with object outputFormat = verbose, failFast = false another type is invalid validateJSON() fails 1`] = `"should be {"foo":"bar","baz":"bax"} but is [1,2] instead"`;

exports[`tests/draft2020-12/const.json const with object outputFormat = verbose, failFast = true another object is invalid validateJSON() fails 1`] = `"should be {"foo":"bar","baz":"bax"} but is {"foo":"bar"} instead"`;

exports[`tests/draft2020-12/const.json const with object outputFormat = verbose, failFast = true another type is invalid validateJSON() fails 1`] = `"should be {"foo":"bar","baz":"bax"} but is [1,2] instead"`;

exports[`tests/draft2020-12/const.json const with true does not match 1 outputFormat = verbose, failFast = false float one is invalid validateJSON() fails 1`] = `"should be true but is 1 instead"`;

exports[`tests/draft2020-12/const.json const with true does not match 1 outputFormat = verbose, failFast = false integer one is invalid validateJSON() fails 1`] = `"should be true but is 1 instead"`;

exports[`tests/draft2020-12/const.json const with true does not match 1 outputFormat = verbose, failFast = true float one is invalid validateJSON() fails 1`] = `"should be true but is 1 instead"`;

exports[`tests/draft2020-12/const.json const with true does not match 1 outputFormat = verbose, failFast = true integer one is invalid validateJSON() fails 1`] = `"should be true but is 1 instead"`;

exports[`tests/draft2020-12/const.json float and integers are equal up to 64-bit representation limits outputFormat = verbose, failFast = false float minus one is invalid validateJSON() fails 1`] = `"should be 9007199254740992 but is 9007199254740991 instead"`;

exports[`tests/draft2020-12/const.json float and integers are equal up to 64-bit representation limits outputFormat = verbose, failFast = false integer minus one is invalid validateJSON() fails 1`] = `"should be 9007199254740992 but is 9007199254740991 instead"`;

exports[`tests/draft2020-12/const.json float and integers are equal up to 64-bit representation limits outputFormat = verbose, failFast = true float minus one is invalid validateJSON() fails 1`] = `"should be 9007199254740992 but is 9007199254740991 instead"`;

exports[`tests/draft2020-12/const.json float and integers are equal up to 64-bit representation limits outputFormat = verbose, failFast = true integer minus one is invalid validateJSON() fails 1`] = `"should be 9007199254740992 but is 9007199254740991 instead"`;

exports[`tests/draft2020-12/const.json nul characters in strings outputFormat = verbose, failFast = false do not match string lacking nul validateJSON() fails 1`] = `"should be 'hello there' but is 'hellothere' instead"`;

exports[`tests/draft2020-12/const.json nul characters in strings outputFormat = verbose, failFast = true do not match string lacking nul validateJSON() fails 1`] = `"should be 'hello there' but is 'hellothere' instead"`;

exports[`tests/draft2020-12/contains.json contains keyword validation outputFormat = verbose, failFast = false array without items matching schema is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains keyword validation outputFormat = verbose, failFast = false empty array is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains keyword validation outputFormat = verbose, failFast = true array without items matching schema is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains keyword validation outputFormat = verbose, failFast = true empty array is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains keyword with boolean schema false outputFormat = verbose, failFast = false any non-empty array is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains keyword with boolean schema false outputFormat = verbose, failFast = false empty array is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains keyword with boolean schema false outputFormat = verbose, failFast = true any non-empty array is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains keyword with boolean schema false outputFormat = verbose, failFast = true empty array is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains keyword with boolean schema true outputFormat = verbose, failFast = false empty array is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains keyword with boolean schema true outputFormat = verbose, failFast = true empty array is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains keyword with const keyword outputFormat = verbose, failFast = false array without item 5 is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains keyword with const keyword outputFormat = verbose, failFast = true array without item 5 is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains with false if subschema outputFormat = verbose, failFast = false empty array is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json contains with false if subschema outputFormat = verbose, failFast = true empty array is invalid validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json items + contains outputFormat = verbose, failFast = false does not match items, matches contains validateJSON() fails 1`] = `"has invalid items at positions 0 and 2 (should be a multiple of 2 but is 3 instead; should be a multiple of 2 but is 9 instead)"`;

exports[`tests/draft2020-12/contains.json items + contains outputFormat = verbose, failFast = false matches items, does not match contains validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json items + contains outputFormat = verbose, failFast = false matches neither items nor contains validateJSON() fails 1`] = `"has invalid items at positions 0 and 1 (should be a multiple of 2 but is 1 instead; should be a multiple of 2 but is 5 instead); does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json items + contains outputFormat = verbose, failFast = true does not match items, matches contains validateJSON() fails 1`] = `"should be a multiple of 2 but is 3 instead"`;

exports[`tests/draft2020-12/contains.json items + contains outputFormat = verbose, failFast = true matches items, does not match contains validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/contains.json items + contains outputFormat = verbose, failFast = true matches neither items nor contains validateJSON() fails 1`] = `"should be a multiple of 2 but is 1 instead"`;

exports[`tests/draft2020-12/default.json the default keyword does not do anything if the property is missing outputFormat = verbose, failFast = false an explicit property value is checked against maximum (failing) validateJSON() fails 1`] = `"has an invalid property alpha (should be less than or equal to 3 but is 5 instead)"`;

exports[`tests/draft2020-12/default.json the default keyword does not do anything if the property is missing outputFormat = verbose, failFast = true an explicit property value is checked against maximum (failing) validateJSON() fails 1`] = `"has an invalid property (alpha should be less than or equal to 3 but is 5 instead)"`;

exports[`tests/draft2020-12/defs.json validate definition against metaschema outputFormat = verbose, failFast = false invalid definition schema validateJSON() fails 1`] = `"has an invalid property $defs (has an invalid property foo (has an invalid property type (does not validate against any subschema)))"`;

exports[`tests/draft2020-12/defs.json validate definition against metaschema outputFormat = verbose, failFast = true invalid definition schema validateJSON() fails 1`] = `"has an invalid property ($defs has an invalid property foo (has an invalid property (type does not validate against any subschema)))"`;

exports[`tests/draft2020-12/dependentRequired.json dependencies with escaped characters outputFormat = verbose, failFast = false CRLF missing dependent validateJSON() fails 1`] = `
"is mising 'foo
bar'"
`;

exports[`tests/draft2020-12/dependentRequired.json dependencies with escaped characters outputFormat = verbose, failFast = false quoted quotes missing dependent validateJSON() fails 1`] = `"is mising 'foo'bar'"`;

exports[`tests/draft2020-12/dependentRequired.json dependencies with escaped characters outputFormat = verbose, failFast = true CRLF missing dependent validateJSON() fails 1`] = `
"is missing 'foo
bar'"
`;

exports[`tests/draft2020-12/dependentRequired.json dependencies with escaped characters outputFormat = verbose, failFast = true quoted quotes missing dependent validateJSON() fails 1`] = `"is missing 'foo'bar'"`;

exports[`tests/draft2020-12/dependentRequired.json multiple dependents required outputFormat = verbose, failFast = false missing both dependencies validateJSON() fails 1`] = `"is mising 'foo' and 'bar'"`;

exports[`tests/draft2020-12/dependentRequired.json multiple dependents required outputFormat = verbose, failFast = false missing dependency validateJSON() fails 1`] = `"is mising 'bar'"`;

exports[`tests/draft2020-12/dependentRequired.json multiple dependents required outputFormat = verbose, failFast = false missing other dependency validateJSON() fails 1`] = `"is mising 'foo'"`;

exports[`tests/draft2020-12/dependentRequired.json multiple dependents required outputFormat = verbose, failFast = true missing both dependencies validateJSON() fails 1`] = `"is missing 'foo'"`;

exports[`tests/draft2020-12/dependentRequired.json multiple dependents required outputFormat = verbose, failFast = true missing dependency validateJSON() fails 1`] = `"is missing 'bar'"`;

exports[`tests/draft2020-12/dependentRequired.json multiple dependents required outputFormat = verbose, failFast = true missing other dependency validateJSON() fails 1`] = `"is missing 'foo'"`;

exports[`tests/draft2020-12/dependentRequired.json single dependency outputFormat = verbose, failFast = false missing dependency validateJSON() fails 1`] = `"is mising 'foo'"`;

exports[`tests/draft2020-12/dependentRequired.json single dependency outputFormat = verbose, failFast = true missing dependency validateJSON() fails 1`] = `"is missing 'foo'"`;

exports[`tests/draft2020-12/dependentSchemas.json boolean subschemas outputFormat = verbose, failFast = false object with both properties is invalid validateJSON() fails 1`] = `"is invalid against dependent schemas of properties 'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json boolean subschemas outputFormat = verbose, failFast = false object with property having schema false is invalid validateJSON() fails 1`] = `"is invalid against dependent schemas of properties 'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json boolean subschemas outputFormat = verbose, failFast = true object with both properties is invalid validateJSON() fails 1`] = `"is invalid against dependent schema of property 'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json boolean subschemas outputFormat = verbose, failFast = true object with property having schema false is invalid validateJSON() fails 1`] = `"is invalid against dependent schema of property 'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json dependencies with escaped characters outputFormat = verbose, failFast = false quoted quote invalid under dependent schema validateJSON() fails 1`] = `"is invalid against dependent schemas of properties 'foo'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json dependencies with escaped characters outputFormat = verbose, failFast = false quoted quote validateJSON() fails 1`] = `"is invalid against dependent schemas of properties 'foo'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json dependencies with escaped characters outputFormat = verbose, failFast = false quoted tab invalid under dependent schema validateJSON() fails 1`] = `"is invalid against dependent schemas of properties 'foo	bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json dependencies with escaped characters outputFormat = verbose, failFast = true quoted quote invalid under dependent schema validateJSON() fails 1`] = `"is invalid against dependent schema of property 'foo'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json dependencies with escaped characters outputFormat = verbose, failFast = true quoted quote validateJSON() fails 1`] = `"is invalid against dependent schema of property 'foo'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json dependencies with escaped characters outputFormat = verbose, failFast = true quoted tab invalid under dependent schema validateJSON() fails 1`] = `"is invalid against dependent schema of property 'foo	bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json dependent subschema incompatible with root outputFormat = verbose, failFast = false matches both validateJSON() fails 1`] = `"is invalid against dependent schemas of properties 'foo'"`;

exports[`tests/draft2020-12/dependentSchemas.json dependent subschema incompatible with root outputFormat = verbose, failFast = false matches root validateJSON() fails 1`] = `"is invalid against dependent schemas of properties 'foo'"`;

exports[`tests/draft2020-12/dependentSchemas.json dependent subschema incompatible with root outputFormat = verbose, failFast = true matches both validateJSON() fails 1`] = `"is invalid against dependent schema of property 'foo'"`;

exports[`tests/draft2020-12/dependentSchemas.json dependent subschema incompatible with root outputFormat = verbose, failFast = true matches root validateJSON() fails 1`] = `"is invalid against dependent schema of property 'foo'"`;

exports[`tests/draft2020-12/dependentSchemas.json single dependency outputFormat = verbose, failFast = false wrong type both validateJSON() fails 1`] = `"is invalid against dependent schemas of properties 'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json single dependency outputFormat = verbose, failFast = false wrong type other validateJSON() fails 1`] = `"is invalid against dependent schemas of properties 'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json single dependency outputFormat = verbose, failFast = false wrong type validateJSON() fails 1`] = `"is invalid against dependent schemas of properties 'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json single dependency outputFormat = verbose, failFast = true wrong type both validateJSON() fails 1`] = `"is invalid against dependent schema of property 'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json single dependency outputFormat = verbose, failFast = true wrong type other validateJSON() fails 1`] = `"is invalid against dependent schema of property 'bar'"`;

exports[`tests/draft2020-12/dependentSchemas.json single dependency outputFormat = verbose, failFast = true wrong type validateJSON() fails 1`] = `"is invalid against dependent schema of property 'bar'"`;

exports[`tests/draft2020-12/dynamicRef.json $ref and $dynamicAnchor are independent of order - $defs first outputFormat = verbose, failFast = false incorrect extended schema validateJSON() fails 1`] = `"has an invalid property elements (has an invalid item at position 0 (has an invalid property b; is missing 'a'))"`;

exports[`tests/draft2020-12/dynamicRef.json $ref and $dynamicAnchor are independent of order - $defs first outputFormat = verbose, failFast = false incorrect parent schema validateJSON() fails 1`] = `"has an invalid property a; is missing 'elements'"`;

exports[`tests/draft2020-12/dynamicRef.json $ref and $dynamicAnchor are independent of order - $defs first outputFormat = verbose, failFast = true incorrect extended schema validateJSON() fails 1`] = `"has an invalid property (elements has a disallowed additional property ('b'))"`;

exports[`tests/draft2020-12/dynamicRef.json $ref and $dynamicAnchor are independent of order - $defs first outputFormat = verbose, failFast = true incorrect parent schema validateJSON() fails 1`] = `"has a disallowed additional property ('a')"`;

exports[`tests/draft2020-12/dynamicRef.json $ref and $dynamicAnchor are independent of order - $ref first outputFormat = verbose, failFast = false incorrect extended schema validateJSON() fails 1`] = `"has an invalid property elements (has an invalid item at position 0 (has an invalid property b; is missing 'a'))"`;

exports[`tests/draft2020-12/dynamicRef.json $ref and $dynamicAnchor are independent of order - $ref first outputFormat = verbose, failFast = false incorrect parent schema validateJSON() fails 1`] = `"has an invalid property a; is missing 'elements'"`;

exports[`tests/draft2020-12/dynamicRef.json $ref and $dynamicAnchor are independent of order - $ref first outputFormat = verbose, failFast = true incorrect extended schema validateJSON() fails 1`] = `"has an invalid property (elements has a disallowed additional property ('b'))"`;

exports[`tests/draft2020-12/dynamicRef.json $ref and $dynamicAnchor are independent of order - $ref first outputFormat = verbose, failFast = true incorrect parent schema validateJSON() fails 1`] = `"has a disallowed additional property ('a')"`;

exports[`tests/draft2020-12/dynamicRef.json $ref to $dynamicRef finds detached $dynamicAnchor outputFormat = verbose, failFast = false non-number is invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/dynamicRef.json $ref to $dynamicRef finds detached $dynamicAnchor outputFormat = verbose, failFast = true non-number is invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/dynamicRef.json A $dynamicRef resolves to the first $dynamicAnchor still in scope that is encountered when the schema is evaluated outputFormat = verbose, failFast = false An array containing non-strings is invalid validateJSON() fails 1`] = `"has an invalid item at position 1 (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/dynamicRef.json A $dynamicRef resolves to the first $dynamicAnchor still in scope that is encountered when the schema is evaluated outputFormat = verbose, failFast = true An array containing non-strings is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/dynamicRef.json A $dynamicRef that initially resolves to a schema with a matching $dynamicAnchor resolves to the first $dynamicAnchor in the dynamic scope outputFormat = verbose, failFast = false The recursive part is not valid against the root validateJSON() fails 1`] = `"has an invalid property bar (has an invalid property baz (has an invalid property foo (should be 'pass' but is 'fail' instead)))"`;

exports[`tests/draft2020-12/dynamicRef.json A $dynamicRef that initially resolves to a schema with a matching $dynamicAnchor resolves to the first $dynamicAnchor in the dynamic scope outputFormat = verbose, failFast = true The recursive part is not valid against the root validateJSON() fails 1`] = `"has an invalid property (bar has an invalid property (baz has an invalid property (foo should be 'pass' but is 'fail' instead)))"`;

exports[`tests/draft2020-12/dynamicRef.json A $dynamicRef to a $dynamicAnchor in the same schema resource behaves like a normal $ref to an $anchor outputFormat = verbose, failFast = false An array containing non-strings is invalid validateJSON() fails 1`] = `"has an invalid item at position 1 (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/dynamicRef.json A $dynamicRef to a $dynamicAnchor in the same schema resource behaves like a normal $ref to an $anchor outputFormat = verbose, failFast = true An array containing non-strings is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/dynamicRef.json A $dynamicRef to an $anchor in the same schema resource behaves like a normal $ref to an $anchor outputFormat = verbose, failFast = false An array containing non-strings is invalid validateJSON() fails 1`] = `"has an invalid item at position 1 (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/dynamicRef.json A $dynamicRef to an $anchor in the same schema resource behaves like a normal $ref to an $anchor outputFormat = verbose, failFast = true An array containing non-strings is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/dynamicRef.json A $dynamicRef with intermediate scopes that don't include a matching $dynamicAnchor does not affect dynamic scope resolution outputFormat = verbose, failFast = false An array containing non-strings is invalid validateJSON() fails 1`] = `"has an invalid item at position 1 (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/dynamicRef.json A $dynamicRef with intermediate scopes that don't include a matching $dynamicAnchor does not affect dynamic scope resolution outputFormat = verbose, failFast = true An array containing non-strings is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/dynamicRef.json A $dynamicRef without anchor in fragment behaves identical to $ref outputFormat = verbose, failFast = false An array of strings is invalid validateJSON() fails 1`] = `"has invalid items at positions 0 and 1 (should be a number but is a string instead; should be a number but is a string instead)"`;

exports[`tests/draft2020-12/dynamicRef.json A $dynamicRef without anchor in fragment behaves identical to $ref outputFormat = verbose, failFast = true An array of strings is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/dynamicRef.json A $ref to a $dynamicAnchor in the same schema resource behaves like a normal $ref to an $anchor outputFormat = verbose, failFast = false An array containing non-strings is invalid validateJSON() fails 1`] = `"has an invalid item at position 1 (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/dynamicRef.json A $ref to a $dynamicAnchor in the same schema resource behaves like a normal $ref to an $anchor outputFormat = verbose, failFast = true An array containing non-strings is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/dynamicRef.json after leaving a dynamic scope, it is not used by a $dynamicRef outputFormat = verbose, failFast = false first_scope is not in dynamic scope for the $dynamicRef validateJSON() fails 1`] = `"should be null but is an integer instead"`;

exports[`tests/draft2020-12/dynamicRef.json after leaving a dynamic scope, it is not used by a $dynamicRef outputFormat = verbose, failFast = false string matches /$defs/thingy, but the $dynamicRef does not stop here validateJSON() fails 1`] = `"should be null but is a string instead"`;

exports[`tests/draft2020-12/dynamicRef.json after leaving a dynamic scope, it is not used by a $dynamicRef outputFormat = verbose, failFast = true first_scope is not in dynamic scope for the $dynamicRef validateJSON() fails 1`] = `"should be null but is an integer instead"`;

exports[`tests/draft2020-12/dynamicRef.json after leaving a dynamic scope, it is not used by a $dynamicRef outputFormat = verbose, failFast = true string matches /$defs/thingy, but the $dynamicRef does not stop here validateJSON() fails 1`] = `"should be null but is a string instead"`;

exports[`tests/draft2020-12/dynamicRef.json multiple dynamic paths to the $dynamicRef keyword outputFormat = verbose, failFast = false number list with string values validateJSON() fails 1`] = `"has an invalid property list (has an invalid item at position 0 (should be a number but is a string instead))"`;

exports[`tests/draft2020-12/dynamicRef.json multiple dynamic paths to the $dynamicRef keyword outputFormat = verbose, failFast = false string list with number values validateJSON() fails 1`] = `"has an invalid property list (has an invalid item at position 0 (should be a string but is a number instead))"`;

exports[`tests/draft2020-12/dynamicRef.json multiple dynamic paths to the $dynamicRef keyword outputFormat = verbose, failFast = true number list with string values validateJSON() fails 1`] = `"has an invalid property (list should be a number but is a string instead)"`;

exports[`tests/draft2020-12/dynamicRef.json multiple dynamic paths to the $dynamicRef keyword outputFormat = verbose, failFast = true string list with number values validateJSON() fails 1`] = `"has an invalid property (list should be a string but is a number instead)"`;

exports[`tests/draft2020-12/dynamicRef.json strict-tree schema, guards against misspelled properties outputFormat = verbose, failFast = false instance with misspelled field validateJSON() fails 1`] = `"has an invalid property children (has an invalid item at position 0 (has an invalid property daat (should not be defined but is 1))); has an invalid property children (should not be defined but is [{"daat":1}])"`;

exports[`tests/draft2020-12/dynamicRef.json strict-tree schema, guards against misspelled properties outputFormat = verbose, failFast = true instance with misspelled field validateJSON() fails 1`] = `"has an invalid property (children has an invalid property daat (should not be defined but is 1))"`;

exports[`tests/draft2020-12/dynamicRef.json tests for implementation dynamic anchor and reference link outputFormat = verbose, failFast = false incorrect extended schema validateJSON() fails 1`] = `"has an invalid property elements (has an invalid item at position 0 (has an invalid property b; is missing 'a'))"`;

exports[`tests/draft2020-12/dynamicRef.json tests for implementation dynamic anchor and reference link outputFormat = verbose, failFast = false incorrect parent schema validateJSON() fails 1`] = `"has an invalid property a; is missing 'elements'"`;

exports[`tests/draft2020-12/dynamicRef.json tests for implementation dynamic anchor and reference link outputFormat = verbose, failFast = true incorrect extended schema validateJSON() fails 1`] = `"has an invalid property (elements has a disallowed additional property ('b'))"`;

exports[`tests/draft2020-12/dynamicRef.json tests for implementation dynamic anchor and reference link outputFormat = verbose, failFast = true incorrect parent schema validateJSON() fails 1`] = `"has a disallowed additional property ('a')"`;

exports[`tests/draft2020-12/enum.json enum with 0 does not match false outputFormat = verbose, failFast = false false is invalid validateJSON() fails 1`] = `"should be 0 but is false instead"`;

exports[`tests/draft2020-12/enum.json enum with 0 does not match false outputFormat = verbose, failFast = true false is invalid validateJSON() fails 1`] = `"should be 0 but is false instead"`;

exports[`tests/draft2020-12/enum.json enum with 1 does not match true outputFormat = verbose, failFast = false true is invalid validateJSON() fails 1`] = `"should be 1 but is true instead"`;

exports[`tests/draft2020-12/enum.json enum with 1 does not match true outputFormat = verbose, failFast = true true is invalid validateJSON() fails 1`] = `"should be 1 but is true instead"`;

exports[`tests/draft2020-12/enum.json enum with escaped characters outputFormat = verbose, failFast = false another string is invalid validateJSON() fails 1`] = `
"should be one of 'foo
bar' or 'foo
bar' but is 'abc' instead"
`;

exports[`tests/draft2020-12/enum.json enum with escaped characters outputFormat = verbose, failFast = true another string is invalid validateJSON() fails 1`] = `
"should be one of 'foo
bar' or 'foo
bar' but is 'abc' instead"
`;

exports[`tests/draft2020-12/enum.json enum with false does not match 0 outputFormat = verbose, failFast = false float zero is invalid validateJSON() fails 1`] = `"should be false but is 0 instead"`;

exports[`tests/draft2020-12/enum.json enum with false does not match 0 outputFormat = verbose, failFast = false integer zero is invalid validateJSON() fails 1`] = `"should be false but is 0 instead"`;

exports[`tests/draft2020-12/enum.json enum with false does not match 0 outputFormat = verbose, failFast = true float zero is invalid validateJSON() fails 1`] = `"should be false but is 0 instead"`;

exports[`tests/draft2020-12/enum.json enum with false does not match 0 outputFormat = verbose, failFast = true integer zero is invalid validateJSON() fails 1`] = `"should be false but is 0 instead"`;

exports[`tests/draft2020-12/enum.json enum with true does not match 1 outputFormat = verbose, failFast = false float one is invalid validateJSON() fails 1`] = `"should be true but is 1 instead"`;

exports[`tests/draft2020-12/enum.json enum with true does not match 1 outputFormat = verbose, failFast = false integer one is invalid validateJSON() fails 1`] = `"should be true but is 1 instead"`;

exports[`tests/draft2020-12/enum.json enum with true does not match 1 outputFormat = verbose, failFast = true float one is invalid validateJSON() fails 1`] = `"should be true but is 1 instead"`;

exports[`tests/draft2020-12/enum.json enum with true does not match 1 outputFormat = verbose, failFast = true integer one is invalid validateJSON() fails 1`] = `"should be true but is 1 instead"`;

exports[`tests/draft2020-12/enum.json enums in properties outputFormat = verbose, failFast = false missing all properties is invalid validateJSON() fails 1`] = `"is missing 'bar'"`;

exports[`tests/draft2020-12/enum.json enums in properties outputFormat = verbose, failFast = false missing required property is invalid validateJSON() fails 1`] = `"is missing 'bar'"`;

exports[`tests/draft2020-12/enum.json enums in properties outputFormat = verbose, failFast = false wrong bar value validateJSON() fails 1`] = `"has an invalid property bar (should be 'bar' but is 'bart' instead)"`;

exports[`tests/draft2020-12/enum.json enums in properties outputFormat = verbose, failFast = false wrong foo value validateJSON() fails 1`] = `"has an invalid property foo (should be 'foo' but is 'foot' instead)"`;

exports[`tests/draft2020-12/enum.json enums in properties outputFormat = verbose, failFast = true missing all properties is invalid validateJSON() fails 1`] = `"is missing 'bar'"`;

exports[`tests/draft2020-12/enum.json enums in properties outputFormat = verbose, failFast = true missing required property is invalid validateJSON() fails 1`] = `"is missing 'bar'"`;

exports[`tests/draft2020-12/enum.json enums in properties outputFormat = verbose, failFast = true wrong bar value validateJSON() fails 1`] = `"has an invalid property (bar should be 'bar' but is 'bart' instead)"`;

exports[`tests/draft2020-12/enum.json enums in properties outputFormat = verbose, failFast = true wrong foo value validateJSON() fails 1`] = `"has an invalid property (foo should be 'foo' but is 'foot' instead)"`;

exports[`tests/draft2020-12/enum.json heterogeneous enum validation outputFormat = verbose, failFast = false extra properties in object is invalid validateJSON() fails 1`] = `"should be one of 6, 'foo', [], true or {"foo":12} but is {"foo":12,"boo":42} instead"`;

exports[`tests/draft2020-12/enum.json heterogeneous enum validation outputFormat = verbose, failFast = false objects are deep compared validateJSON() fails 1`] = `"should be one of 6, 'foo', [], true or {"foo":12} but is {"foo":false} instead"`;

exports[`tests/draft2020-12/enum.json heterogeneous enum validation outputFormat = verbose, failFast = false something else is invalid validateJSON() fails 1`] = `"should be one of 6, 'foo', [], true or {"foo":12} but is null instead"`;

exports[`tests/draft2020-12/enum.json heterogeneous enum validation outputFormat = verbose, failFast = true extra properties in object is invalid validateJSON() fails 1`] = `"should be one of 6, 'foo', [], true or {"foo":12} but is {"foo":12,"boo":42} instead"`;

exports[`tests/draft2020-12/enum.json heterogeneous enum validation outputFormat = verbose, failFast = true objects are deep compared validateJSON() fails 1`] = `"should be one of 6, 'foo', [], true or {"foo":12} but is {"foo":false} instead"`;

exports[`tests/draft2020-12/enum.json heterogeneous enum validation outputFormat = verbose, failFast = true something else is invalid validateJSON() fails 1`] = `"should be one of 6, 'foo', [], true or {"foo":12} but is null instead"`;

exports[`tests/draft2020-12/enum.json heterogeneous enum-with-null validation outputFormat = verbose, failFast = false something else is invalid validateJSON() fails 1`] = `"should be one of 6 or null but is 'test' instead"`;

exports[`tests/draft2020-12/enum.json heterogeneous enum-with-null validation outputFormat = verbose, failFast = true something else is invalid validateJSON() fails 1`] = `"should be one of 6 or null but is 'test' instead"`;

exports[`tests/draft2020-12/enum.json nul characters in strings outputFormat = verbose, failFast = false do not match string lacking nul validateJSON() fails 1`] = `"should be 'hello there' but is 'hellothere' instead"`;

exports[`tests/draft2020-12/enum.json nul characters in strings outputFormat = verbose, failFast = true do not match string lacking nul validateJSON() fails 1`] = `"should be 'hello there' but is 'hellothere' instead"`;

exports[`tests/draft2020-12/enum.json simple enum validation outputFormat = verbose, failFast = false something else is invalid validateJSON() fails 1`] = `"should be one of 1, 2 or 3 but is 4 instead"`;

exports[`tests/draft2020-12/enum.json simple enum validation outputFormat = verbose, failFast = true something else is invalid validateJSON() fails 1`] = `"should be one of 1, 2 or 3 but is 4 instead"`;

exports[`tests/draft2020-12/exclusiveMaximum.json exclusiveMaximum validation outputFormat = verbose, failFast = false above the exclusiveMaximum is invalid validateJSON() fails 1`] = `"should be less than 3 but is 3.5 instead"`;

exports[`tests/draft2020-12/exclusiveMaximum.json exclusiveMaximum validation outputFormat = verbose, failFast = false boundary point is invalid validateJSON() fails 1`] = `"should be less than 3 but is 3 instead"`;

exports[`tests/draft2020-12/exclusiveMaximum.json exclusiveMaximum validation outputFormat = verbose, failFast = true above the exclusiveMaximum is invalid validateJSON() fails 1`] = `"should be less than 3 but is 3.5 instead"`;

exports[`tests/draft2020-12/exclusiveMaximum.json exclusiveMaximum validation outputFormat = verbose, failFast = true boundary point is invalid validateJSON() fails 1`] = `"should be less than 3 but is 3 instead"`;

exports[`tests/draft2020-12/exclusiveMinimum.json exclusiveMinimum validation outputFormat = verbose, failFast = false below the exclusiveMinimum is invalid validateJSON() fails 1`] = `"should be greater than 1.1 but is 0.6 instead"`;

exports[`tests/draft2020-12/exclusiveMinimum.json exclusiveMinimum validation outputFormat = verbose, failFast = false boundary point is invalid validateJSON() fails 1`] = `"should be greater than 1.1 but is 1.1 instead"`;

exports[`tests/draft2020-12/exclusiveMinimum.json exclusiveMinimum validation outputFormat = verbose, failFast = true below the exclusiveMinimum is invalid validateJSON() fails 1`] = `"should be greater than 1.1 but is 0.6 instead"`;

exports[`tests/draft2020-12/exclusiveMinimum.json exclusiveMinimum validation outputFormat = verbose, failFast = true boundary point is invalid validateJSON() fails 1`] = `"should be greater than 1.1 but is 1.1 instead"`;

exports[`tests/draft2020-12/id.json $id inside an enum is not a real identifier outputFormat = verbose, failFast = false no match on enum or $ref to $id validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/id.json $id inside an enum is not a real identifier outputFormat = verbose, failFast = true no match on enum or $ref to $id validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = false Identifier name and no ref validateJSON() fails 1`] = `"has an invalid property $defs (has an invalid property A (has an invalid property $id (should match '^[^#]*#?$' but is '#foo' instead)))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = false Identifier name validateJSON() fails 1`] = `"has an invalid property $defs (has an invalid property A (has an invalid property $id (should match '^[^#]*#?$' but is '#foo' instead)))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = false Identifier name with absolute URI validateJSON() fails 1`] = `"has an invalid property $defs (has an invalid property A (has an invalid property $id (should match '^[^#]*#?$' but is 'http://localhost:1234/draft2020-12/bar#foo' instead)))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = false Identifier name with base URI change in subschema validateJSON() fails 1`] = `"has an invalid property $defs (has an invalid property A (has an invalid property $defs (has an invalid property B (has an invalid property $id (should match '^[^#]*#?$' but is '#foo' instead)))))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = false Identifier path validateJSON() fails 1`] = `"has an invalid property $defs (has an invalid property A (has an invalid property $id (should match '^[^#]*#?$' but is '#/a/b' instead)))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = false Identifier path with absolute URI validateJSON() fails 1`] = `"has an invalid property $defs (has an invalid property A (has an invalid property $id (should match '^[^#]*#?$' but is 'http://localhost:1234/draft2020-12/bar#/a/b' instead)))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = false Identifier path with base URI change in subschema validateJSON() fails 1`] = `"has an invalid property $defs (has an invalid property A (has an invalid property $defs (has an invalid property B (has an invalid property $id (should match '^[^#]*#?$' but is '#/a/b' instead)))))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = true Identifier name and no ref validateJSON() fails 1`] = `"has an invalid property ($defs has an invalid property A (has an invalid property ($id should match '^[^#]*#?$' but is '#foo' instead)))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = true Identifier name validateJSON() fails 1`] = `"has an invalid property ($defs has an invalid property A (has an invalid property ($id should match '^[^#]*#?$' but is '#foo' instead)))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = true Identifier name with absolute URI validateJSON() fails 1`] = `"has an invalid property ($defs has an invalid property A (has an invalid property ($id should match '^[^#]*#?$' but is 'http://localhost:1234/draft2020-12/bar#foo' instead)))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = true Identifier name with base URI change in subschema validateJSON() fails 1`] = `"has an invalid property ($defs has an invalid property A (has an invalid property ($defs has an invalid property B (has an invalid property ($id should match '^[^#]*#?$' but is '#foo' instead)))))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = true Identifier path validateJSON() fails 1`] = `"has an invalid property ($defs has an invalid property A (has an invalid property ($id should match '^[^#]*#?$' but is '#/a/b' instead)))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = true Identifier path with absolute URI validateJSON() fails 1`] = `"has an invalid property ($defs has an invalid property A (has an invalid property ($id should match '^[^#]*#?$' but is 'http://localhost:1234/draft2020-12/bar#/a/b' instead)))"`;

exports[`tests/draft2020-12/id.json Invalid use of fragments in location-independent $id outputFormat = verbose, failFast = true Identifier path with base URI change in subschema validateJSON() fails 1`] = `"has an invalid property ($defs has an invalid property A (has an invalid property ($defs has an invalid property B (has an invalid property ($id should match '^[^#]*#?$' but is '#/a/b' instead)))))"`;

exports[`tests/draft2020-12/id.json non-schema object containing an $id property outputFormat = verbose, failFast = false const at const_not_id does not match validateJSON() fails 1`] = `"should be {"$id":"not_a_real_id"} but is 1 instead"`;

exports[`tests/draft2020-12/id.json non-schema object containing an $id property outputFormat = verbose, failFast = true const at const_not_id does not match validateJSON() fails 1`] = `"should be {"$id":"not_a_real_id"} but is 1 instead"`;

exports[`tests/draft2020-12/if-then-else.json if and else without then outputFormat = verbose, failFast = false invalid through else validateJSON() fails 1`] = `"should be a multiple of 2 but is 3 instead"`;

exports[`tests/draft2020-12/if-then-else.json if and else without then outputFormat = verbose, failFast = true invalid through else validateJSON() fails 1`] = `"should be a multiple of 2 but is 3 instead"`;

exports[`tests/draft2020-12/if-then-else.json if and then without else outputFormat = verbose, failFast = false invalid through then validateJSON() fails 1`] = `"should be greater than or equal to -10 but is -100 instead"`;

exports[`tests/draft2020-12/if-then-else.json if and then without else outputFormat = verbose, failFast = true invalid through then validateJSON() fails 1`] = `"should be greater than or equal to -10 but is -100 instead"`;

exports[`tests/draft2020-12/if-then-else.json if appears at the end when serialized (keyword processing sequence) outputFormat = verbose, failFast = false invalid redirects to else and fails validateJSON() fails 1`] = `"should be 'other' but is 'invalid' instead"`;

exports[`tests/draft2020-12/if-then-else.json if appears at the end when serialized (keyword processing sequence) outputFormat = verbose, failFast = false no redirects to then and fails validateJSON() fails 1`] = `"should be 'yes' but is 'no' instead"`;

exports[`tests/draft2020-12/if-then-else.json if appears at the end when serialized (keyword processing sequence) outputFormat = verbose, failFast = true invalid redirects to else and fails validateJSON() fails 1`] = `"should be 'other' but is 'invalid' instead"`;

exports[`tests/draft2020-12/if-then-else.json if appears at the end when serialized (keyword processing sequence) outputFormat = verbose, failFast = true no redirects to then and fails validateJSON() fails 1`] = `"should be 'yes' but is 'no' instead"`;

exports[`tests/draft2020-12/if-then-else.json if with boolean schema false outputFormat = verbose, failFast = false boolean schema false in if always chooses the else path (invalid) validateJSON() fails 1`] = `"should be 'else' but is 'then' instead"`;

exports[`tests/draft2020-12/if-then-else.json if with boolean schema false outputFormat = verbose, failFast = true boolean schema false in if always chooses the else path (invalid) validateJSON() fails 1`] = `"should be 'else' but is 'then' instead"`;

exports[`tests/draft2020-12/if-then-else.json if with boolean schema true outputFormat = verbose, failFast = false boolean schema true in if always chooses the then path (invalid) validateJSON() fails 1`] = `"should be 'then' but is 'else' instead"`;

exports[`tests/draft2020-12/if-then-else.json if with boolean schema true outputFormat = verbose, failFast = true boolean schema true in if always chooses the then path (invalid) validateJSON() fails 1`] = `"should be 'then' but is 'else' instead"`;

exports[`tests/draft2020-12/if-then-else.json validate against correct branch, then vs else outputFormat = verbose, failFast = false invalid through else validateJSON() fails 1`] = `"should be a multiple of 2 but is 3 instead"`;

exports[`tests/draft2020-12/if-then-else.json validate against correct branch, then vs else outputFormat = verbose, failFast = false invalid through then validateJSON() fails 1`] = `"should be greater than or equal to -10 but is -100 instead"`;

exports[`tests/draft2020-12/if-then-else.json validate against correct branch, then vs else outputFormat = verbose, failFast = true invalid through else validateJSON() fails 1`] = `"should be a multiple of 2 but is 3 instead"`;

exports[`tests/draft2020-12/if-then-else.json validate against correct branch, then vs else outputFormat = verbose, failFast = true invalid through then validateJSON() fails 1`] = `"should be greater than or equal to -10 but is -100 instead"`;

exports[`tests/draft2020-12/infinite-loop-detection.json evaluating the same schema location against the same data location twice is not a sign of an infinite loop outputFormat = verbose, failFast = false failing case validateJSON() fails 1`] = `"has an invalid property foo (should be an integer but is a string instead) and has an invalid property foo (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/infinite-loop-detection.json evaluating the same schema location against the same data location twice is not a sign of an infinite loop outputFormat = verbose, failFast = true failing case validateJSON() fails 1`] = `"has an invalid property (foo should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/items.json a schema given for items outputFormat = verbose, failFast = false wrong type of items validateJSON() fails 1`] = `"has an invalid item at position 1 (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/items.json a schema given for items outputFormat = verbose, failFast = true wrong type of items validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/items.json items and subitems outputFormat = verbose, failFast = false too many items validateJSON() fails 1`] = `"has an invalid item at position 3 (should not be defined but is [{"foo":null},{"foo":null}])"`;

exports[`tests/draft2020-12/items.json items and subitems outputFormat = verbose, failFast = false too many sub-items validateJSON() fails 1`] = `"has an invalid item at position 0 (has an invalid item at position 2 (should not be defined but is {"foo":null}))"`;

exports[`tests/draft2020-12/items.json items and subitems outputFormat = verbose, failFast = false wrong item validateJSON() fails 1`] = `"has an invalid item at position 0 (should be an array but is an object instead)"`;

exports[`tests/draft2020-12/items.json items and subitems outputFormat = verbose, failFast = false wrong sub-item validateJSON() fails 1`] = `"has an invalid item at position 0 (has an invalid item at position 0 (is missing 'foo'))"`;

exports[`tests/draft2020-12/items.json items and subitems outputFormat = verbose, failFast = true too many items validateJSON() fails 1`] = `"should not be defined but is [{"foo":null},{"foo":null}]"`;

exports[`tests/draft2020-12/items.json items and subitems outputFormat = verbose, failFast = true too many sub-items validateJSON() fails 1`] = `"should not be defined but is {"foo":null}"`;

exports[`tests/draft2020-12/items.json items and subitems outputFormat = verbose, failFast = true wrong item validateJSON() fails 1`] = `"should be an array but is an object instead"`;

exports[`tests/draft2020-12/items.json items and subitems outputFormat = verbose, failFast = true wrong sub-item validateJSON() fails 1`] = `"is missing 'foo'"`;

exports[`tests/draft2020-12/items.json items does not look in applicators, valid case outputFormat = verbose, failFast = false prefixItems in allOf does not constrain items, invalid case validateJSON() fails 1`] = `"has an invalid item at position 0 (should be greater than or equal to 5 but is 3 instead)"`;

exports[`tests/draft2020-12/items.json items does not look in applicators, valid case outputFormat = verbose, failFast = true prefixItems in allOf does not constrain items, invalid case validateJSON() fails 1`] = `"should be greater than or equal to 5 but is 3 instead"`;

exports[`tests/draft2020-12/items.json items with boolean schema (false) outputFormat = verbose, failFast = false any non-empty array is invalid validateJSON() fails 1`] = `"has invalid items at positions 0, 1 and 2 (should not be defined but is 1; should not be defined but is 'foo'; should not be defined but is true)"`;

exports[`tests/draft2020-12/items.json items with boolean schema (false) outputFormat = verbose, failFast = true any non-empty array is invalid validateJSON() fails 1`] = `"should not be defined but is 1"`;

exports[`tests/draft2020-12/items.json nested items outputFormat = verbose, failFast = false nested array with invalid type validateJSON() fails 1`] = `"has an invalid item at position 0 (has an invalid item at position 0 (has an invalid item at position 0 (has an invalid item at position 0 (should be a number but is a string instead))))"`;

exports[`tests/draft2020-12/items.json nested items outputFormat = verbose, failFast = false not deep enough validateJSON() fails 1`] = `"has invalid items at positions 0 and 1 (has invalid items at positions 0, 1 and 2 (has an invalid item at position 0 (should be an array but is an integer instead); has an invalid item at position 0 (should be an array but is an integer instead); has an invalid item at position 0 (should be an array but is an integer instead)); has invalid items at positions 0, 1 and 2 (has an invalid item at position 0 (should be an array but is an integer instead); has an invalid item at position 0 (should be an array but is an integer instead); has an invalid item at position 0 (should be an array but is an integer instead)))"`;

exports[`tests/draft2020-12/items.json nested items outputFormat = verbose, failFast = true nested array with invalid type validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/items.json nested items outputFormat = verbose, failFast = true not deep enough validateJSON() fails 1`] = `"should be an array but is an integer instead"`;

exports[`tests/draft2020-12/items.json prefixItems validation adjusts the starting index for items outputFormat = verbose, failFast = false wrong type of second item validateJSON() fails 1`] = `"has an invalid item at position 1 (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/items.json prefixItems validation adjusts the starting index for items outputFormat = verbose, failFast = true wrong type of second item validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/items.json prefixItems with no additional items allowed outputFormat = verbose, failFast = false additional items are not permitted validateJSON() fails 1`] = `"has an invalid item at position 3 (should not be defined but is 4)"`;

exports[`tests/draft2020-12/items.json prefixItems with no additional items allowed outputFormat = verbose, failFast = true additional items are not permitted validateJSON() fails 1`] = `"should not be defined but is 4"`;

exports[`tests/draft2020-12/maxContains.json maxContains with contains outputFormat = verbose, failFast = false all elements match, invalid maxContains validateJSON() fails 1`] = `"should have up to 1 item that validate against subschema but has 2 at 0 and 1 instead"`;

exports[`tests/draft2020-12/maxContains.json maxContains with contains outputFormat = verbose, failFast = false empty data validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/maxContains.json maxContains with contains outputFormat = verbose, failFast = false some elements match, invalid maxContains validateJSON() fails 1`] = `"should have up to 1 item that validate against subschema but has 2 at 0 and 2 instead"`;

exports[`tests/draft2020-12/maxContains.json maxContains with contains outputFormat = verbose, failFast = true all elements match, invalid maxContains validateJSON() fails 1`] = `"should have up to 1 item that validate against subschema but has 2 at 0 and 1 instead"`;

exports[`tests/draft2020-12/maxContains.json maxContains with contains outputFormat = verbose, failFast = true empty data validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/maxContains.json maxContains with contains outputFormat = verbose, failFast = true some elements match, invalid maxContains validateJSON() fails 1`] = `"should have up to 1 item that validate against subschema but has 2 at 0 and 2 instead"`;

exports[`tests/draft2020-12/maxContains.json maxContains with contains, value with a decimal outputFormat = verbose, failFast = false too many elements match, invalid maxContains validateJSON() fails 1`] = `"should have up to 1 item that validate against subschema but has 2 at 0 and 1 instead"`;

exports[`tests/draft2020-12/maxContains.json maxContains with contains, value with a decimal outputFormat = verbose, failFast = true too many elements match, invalid maxContains validateJSON() fails 1`] = `"should have up to 1 item that validate against subschema but has 2 at 0 and 1 instead"`;

exports[`tests/draft2020-12/maxContains.json minContains < maxContains outputFormat = verbose, failFast = false actual < minContains < maxContains validateJSON() fails 1`] = `"does not contain an item that validates against a subschema; should have at least 1 item that validate against subschema but has 0 at  instead"`;

exports[`tests/draft2020-12/maxContains.json minContains < maxContains outputFormat = verbose, failFast = false minContains < maxContains < actual validateJSON() fails 1`] = `"should have up to 3 items that validate against subschema but has 4 at 0, 1, 2 and 3 instead"`;

exports[`tests/draft2020-12/maxContains.json minContains < maxContains outputFormat = verbose, failFast = true actual < minContains < maxContains validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/maxContains.json minContains < maxContains outputFormat = verbose, failFast = true minContains < maxContains < actual validateJSON() fails 1`] = `"should have up to 3 items that validate against subschema but has 4 at 0, 1, 2 and 3 instead"`;

exports[`tests/draft2020-12/maxItems.json maxItems validation outputFormat = verbose, failFast = false too long is invalid validateJSON() fails 1`] = `"should have up to 2 items but has 3 instead"`;

exports[`tests/draft2020-12/maxItems.json maxItems validation outputFormat = verbose, failFast = true too long is invalid validateJSON() fails 1`] = `"should have up to 2 items but has 3 instead"`;

exports[`tests/draft2020-12/maxItems.json maxItems validation with a decimal outputFormat = verbose, failFast = false too long is invalid validateJSON() fails 1`] = `"should have up to 2 items but has 3 instead"`;

exports[`tests/draft2020-12/maxItems.json maxItems validation with a decimal outputFormat = verbose, failFast = true too long is invalid validateJSON() fails 1`] = `"should have up to 2 items but has 3 instead"`;

exports[`tests/draft2020-12/maxLength.json maxLength validation outputFormat = verbose, failFast = false too long is invalid validateJSON() fails 1`] = `"should have up to 2 characters but has 3 instead"`;

exports[`tests/draft2020-12/maxLength.json maxLength validation outputFormat = verbose, failFast = true too long is invalid validateJSON() fails 1`] = `"should have up to 2 characters but has 3 instead"`;

exports[`tests/draft2020-12/maxLength.json maxLength validation with a decimal outputFormat = verbose, failFast = false too long is invalid validateJSON() fails 1`] = `"should have up to 2 characters but has 3 instead"`;

exports[`tests/draft2020-12/maxLength.json maxLength validation with a decimal outputFormat = verbose, failFast = true too long is invalid validateJSON() fails 1`] = `"should have up to 2 characters but has 3 instead"`;

exports[`tests/draft2020-12/maxProperties.json maxProperties = 0 means the object is empty outputFormat = verbose, failFast = false one property is invalid validateJSON() fails 1`] = `"should have up to 0 properties but has 1 instead"`;

exports[`tests/draft2020-12/maxProperties.json maxProperties = 0 means the object is empty outputFormat = verbose, failFast = true one property is invalid validateJSON() fails 1`] = `"should have up to 0 properties but has 1 instead"`;

exports[`tests/draft2020-12/maxProperties.json maxProperties validation outputFormat = verbose, failFast = false too long is invalid validateJSON() fails 1`] = `"should have up to 2 properties but has 3 instead"`;

exports[`tests/draft2020-12/maxProperties.json maxProperties validation outputFormat = verbose, failFast = true too long is invalid validateJSON() fails 1`] = `"should have up to 2 properties but has 3 instead"`;

exports[`tests/draft2020-12/maxProperties.json maxProperties validation with a decimal outputFormat = verbose, failFast = false too long is invalid validateJSON() fails 1`] = `"should have up to 2 properties but has 3 instead"`;

exports[`tests/draft2020-12/maxProperties.json maxProperties validation with a decimal outputFormat = verbose, failFast = true too long is invalid validateJSON() fails 1`] = `"should have up to 2 properties but has 3 instead"`;

exports[`tests/draft2020-12/maximum.json maximum validation outputFormat = verbose, failFast = false above the maximum is invalid validateJSON() fails 1`] = `"should be less than or equal to 3 but is 3.5 instead"`;

exports[`tests/draft2020-12/maximum.json maximum validation outputFormat = verbose, failFast = true above the maximum is invalid validateJSON() fails 1`] = `"should be less than or equal to 3 but is 3.5 instead"`;

exports[`tests/draft2020-12/maximum.json maximum validation with unsigned integer outputFormat = verbose, failFast = false above the maximum is invalid validateJSON() fails 1`] = `"should be less than or equal to 300 but is 300.5 instead"`;

exports[`tests/draft2020-12/maximum.json maximum validation with unsigned integer outputFormat = verbose, failFast = true above the maximum is invalid validateJSON() fails 1`] = `"should be less than or equal to 300 but is 300.5 instead"`;

exports[`tests/draft2020-12/minContains.json maxContains < minContains outputFormat = verbose, failFast = false empty data validateJSON() fails 1`] = `"does not contain an item that validates against a subschema; should have at least 3 items that validate against subschema but has 0 at  instead"`;

exports[`tests/draft2020-12/minContains.json maxContains < minContains outputFormat = verbose, failFast = false invalid maxContains and minContains validateJSON() fails 1`] = `"should have up to 1 item that validate against subschema but has 2 at 0 and 1 instead; should have at least 3 items that validate against subschema but has 2 at 0 and 1 instead"`;

exports[`tests/draft2020-12/minContains.json maxContains < minContains outputFormat = verbose, failFast = false invalid maxContains validateJSON() fails 1`] = `"should have up to 1 item that validate against subschema but has 3 at 0, 1 and 2 instead"`;

exports[`tests/draft2020-12/minContains.json maxContains < minContains outputFormat = verbose, failFast = false invalid minContains validateJSON() fails 1`] = `"should have at least 3 items that validate against subschema but has 1 at 0 instead"`;

exports[`tests/draft2020-12/minContains.json maxContains < minContains outputFormat = verbose, failFast = true empty data validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/minContains.json maxContains < minContains outputFormat = verbose, failFast = true invalid maxContains and minContains validateJSON() fails 1`] = `"should have up to 1 item that validate against subschema but has 2 at 0 and 1 instead"`;

exports[`tests/draft2020-12/minContains.json maxContains < minContains outputFormat = verbose, failFast = true invalid maxContains validateJSON() fails 1`] = `"should have up to 1 item that validate against subschema but has 3 at 0, 1 and 2 instead"`;

exports[`tests/draft2020-12/minContains.json maxContains < minContains outputFormat = verbose, failFast = true invalid minContains validateJSON() fails 1`] = `"should have at least 3 items that validate against subschema but has 1 at 0 instead"`;

exports[`tests/draft2020-12/minContains.json maxContains = minContains outputFormat = verbose, failFast = false all elements match, invalid maxContains validateJSON() fails 1`] = `"should have up to 2 items that validate against subschema but has 3 at 0, 1 and 2 instead"`;

exports[`tests/draft2020-12/minContains.json maxContains = minContains outputFormat = verbose, failFast = false all elements match, invalid minContains validateJSON() fails 1`] = `"should have at least 2 items that validate against subschema but has 1 at 0 instead"`;

exports[`tests/draft2020-12/minContains.json maxContains = minContains outputFormat = verbose, failFast = false empty data validateJSON() fails 1`] = `"does not contain an item that validates against a subschema; should have at least 2 items that validate against subschema but has 0 at  instead"`;

exports[`tests/draft2020-12/minContains.json maxContains = minContains outputFormat = verbose, failFast = true all elements match, invalid maxContains validateJSON() fails 1`] = `"should have up to 2 items that validate against subschema but has 3 at 0, 1 and 2 instead"`;

exports[`tests/draft2020-12/minContains.json maxContains = minContains outputFormat = verbose, failFast = true all elements match, invalid minContains validateJSON() fails 1`] = `"should have at least 2 items that validate against subschema but has 1 at 0 instead"`;

exports[`tests/draft2020-12/minContains.json maxContains = minContains outputFormat = verbose, failFast = true empty data validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/minContains.json minContains = 0 with maxContains outputFormat = verbose, failFast = false too many validateJSON() fails 1`] = `"should have up to 1 item that validate against subschema but has 2 at 0 and 1 instead"`;

exports[`tests/draft2020-12/minContains.json minContains = 0 with maxContains outputFormat = verbose, failFast = true too many validateJSON() fails 1`] = `"should have up to 1 item that validate against subschema but has 2 at 0 and 1 instead"`;

exports[`tests/draft2020-12/minContains.json minContains=1 with contains outputFormat = verbose, failFast = false empty data validateJSON() fails 1`] = `"does not contain an item that validates against a subschema; should have at least 1 item that validate against subschema but has 0 at  instead"`;

exports[`tests/draft2020-12/minContains.json minContains=1 with contains outputFormat = verbose, failFast = false no elements match validateJSON() fails 1`] = `"does not contain an item that validates against a subschema; should have at least 1 item that validate against subschema but has 0 at  instead"`;

exports[`tests/draft2020-12/minContains.json minContains=1 with contains outputFormat = verbose, failFast = true empty data validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/minContains.json minContains=1 with contains outputFormat = verbose, failFast = true no elements match validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/minContains.json minContains=2 with contains outputFormat = verbose, failFast = false all elements match, invalid minContains validateJSON() fails 1`] = `"should have at least 2 items that validate against subschema but has 1 at 0 instead"`;

exports[`tests/draft2020-12/minContains.json minContains=2 with contains outputFormat = verbose, failFast = false empty data validateJSON() fails 1`] = `"does not contain an item that validates against a subschema; should have at least 2 items that validate against subschema but has 0 at  instead"`;

exports[`tests/draft2020-12/minContains.json minContains=2 with contains outputFormat = verbose, failFast = false some elements match, invalid minContains validateJSON() fails 1`] = `"should have at least 2 items that validate against subschema but has 1 at 0 instead"`;

exports[`tests/draft2020-12/minContains.json minContains=2 with contains outputFormat = verbose, failFast = true all elements match, invalid minContains validateJSON() fails 1`] = `"should have at least 2 items that validate against subschema but has 1 at 0 instead"`;

exports[`tests/draft2020-12/minContains.json minContains=2 with contains outputFormat = verbose, failFast = true empty data validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/minContains.json minContains=2 with contains outputFormat = verbose, failFast = true some elements match, invalid minContains validateJSON() fails 1`] = `"should have at least 2 items that validate against subschema but has 1 at 0 instead"`;

exports[`tests/draft2020-12/minContains.json minContains=2 with contains with a decimal value outputFormat = verbose, failFast = false one element matches, invalid minContains validateJSON() fails 1`] = `"should have at least 2 items that validate against subschema but has 1 at 0 instead"`;

exports[`tests/draft2020-12/minContains.json minContains=2 with contains with a decimal value outputFormat = verbose, failFast = true one element matches, invalid minContains validateJSON() fails 1`] = `"should have at least 2 items that validate against subschema but has 1 at 0 instead"`;

exports[`tests/draft2020-12/minItems.json minItems validation outputFormat = verbose, failFast = false too short is invalid validateJSON() fails 1`] = `"should have at least 1 item but has 0 instead"`;

exports[`tests/draft2020-12/minItems.json minItems validation outputFormat = verbose, failFast = true too short is invalid validateJSON() fails 1`] = `"should have at least 1 item but has 0 instead"`;

exports[`tests/draft2020-12/minItems.json minItems validation with a decimal outputFormat = verbose, failFast = false too short is invalid validateJSON() fails 1`] = `"should have at least 1 item but has 0 instead"`;

exports[`tests/draft2020-12/minItems.json minItems validation with a decimal outputFormat = verbose, failFast = true too short is invalid validateJSON() fails 1`] = `"should have at least 1 item but has 0 instead"`;

exports[`tests/draft2020-12/minLength.json minLength validation outputFormat = verbose, failFast = false one supplementary Unicode code point is not long enough validateJSON() fails 1`] = `"should have at least 2 characters but has 1 instead"`;

exports[`tests/draft2020-12/minLength.json minLength validation outputFormat = verbose, failFast = false too short is invalid validateJSON() fails 1`] = `"should have at least 2 characters but has 1 instead"`;

exports[`tests/draft2020-12/minLength.json minLength validation outputFormat = verbose, failFast = true one supplementary Unicode code point is not long enough validateJSON() fails 1`] = `"should have at least 2 characters but has 1 instead"`;

exports[`tests/draft2020-12/minLength.json minLength validation outputFormat = verbose, failFast = true too short is invalid validateJSON() fails 1`] = `"should have at least 2 characters but has 1 instead"`;

exports[`tests/draft2020-12/minLength.json minLength validation with a decimal outputFormat = verbose, failFast = false too short is invalid validateJSON() fails 1`] = `"should have at least 2 characters but has 1 instead"`;

exports[`tests/draft2020-12/minLength.json minLength validation with a decimal outputFormat = verbose, failFast = true too short is invalid validateJSON() fails 1`] = `"should have at least 2 characters but has 1 instead"`;

exports[`tests/draft2020-12/minProperties.json minProperties validation outputFormat = verbose, failFast = false too short is invalid validateJSON() fails 1`] = `"should have at least 1 property but has 0 instead"`;

exports[`tests/draft2020-12/minProperties.json minProperties validation outputFormat = verbose, failFast = true too short is invalid validateJSON() fails 1`] = `"should have at least 1 property but has 0 instead"`;

exports[`tests/draft2020-12/minProperties.json minProperties validation with a decimal outputFormat = verbose, failFast = false too short is invalid validateJSON() fails 1`] = `"should have at least 1 property but has 0 instead"`;

exports[`tests/draft2020-12/minProperties.json minProperties validation with a decimal outputFormat = verbose, failFast = true too short is invalid validateJSON() fails 1`] = `"should have at least 1 property but has 0 instead"`;

exports[`tests/draft2020-12/minimum.json minimum validation outputFormat = verbose, failFast = false below the minimum is invalid validateJSON() fails 1`] = `"should be greater than or equal to 1.1 but is 0.6 instead"`;

exports[`tests/draft2020-12/minimum.json minimum validation outputFormat = verbose, failFast = true below the minimum is invalid validateJSON() fails 1`] = `"should be greater than or equal to 1.1 but is 0.6 instead"`;

exports[`tests/draft2020-12/minimum.json minimum validation with signed integer outputFormat = verbose, failFast = false float below the minimum is invalid validateJSON() fails 1`] = `"should be greater than or equal to -2 but is -2.0001 instead"`;

exports[`tests/draft2020-12/minimum.json minimum validation with signed integer outputFormat = verbose, failFast = false int below the minimum is invalid validateJSON() fails 1`] = `"should be greater than or equal to -2 but is -3 instead"`;

exports[`tests/draft2020-12/minimum.json minimum validation with signed integer outputFormat = verbose, failFast = true float below the minimum is invalid validateJSON() fails 1`] = `"should be greater than or equal to -2 but is -2.0001 instead"`;

exports[`tests/draft2020-12/minimum.json minimum validation with signed integer outputFormat = verbose, failFast = true int below the minimum is invalid validateJSON() fails 1`] = `"should be greater than or equal to -2 but is -3 instead"`;

exports[`tests/draft2020-12/multipleOf.json by int outputFormat = verbose, failFast = false int by int fail validateJSON() fails 1`] = `"should be a multiple of 2 but is 7 instead"`;

exports[`tests/draft2020-12/multipleOf.json by int outputFormat = verbose, failFast = true int by int fail validateJSON() fails 1`] = `"should be a multiple of 2 but is 7 instead"`;

exports[`tests/draft2020-12/multipleOf.json by number outputFormat = verbose, failFast = false 35 is not multiple of 1.5 validateJSON() fails 1`] = `"should be a multiple of 1.5 but is 35 instead"`;

exports[`tests/draft2020-12/multipleOf.json by number outputFormat = verbose, failFast = true 35 is not multiple of 1.5 validateJSON() fails 1`] = `"should be a multiple of 1.5 but is 35 instead"`;

exports[`tests/draft2020-12/multipleOf.json by small number outputFormat = verbose, failFast = false 0.00751 is not multiple of 0.0001 validateJSON() fails 1`] = `"should be a multiple of 0.0001 but is 0.00751 instead"`;

exports[`tests/draft2020-12/multipleOf.json by small number outputFormat = verbose, failFast = true 0.00751 is not multiple of 0.0001 validateJSON() fails 1`] = `"should be a multiple of 0.0001 but is 0.00751 instead"`;

exports[`tests/draft2020-12/multipleOf.json float division = inf outputFormat = verbose, failFast = false always invalid, but naive implementations may raise an overflow error validateJSON() fails 1`] = `"should be a multiple of 0.123456789 but is 1e+308 instead"`;

exports[`tests/draft2020-12/multipleOf.json float division = inf outputFormat = verbose, failFast = true always invalid, but naive implementations may raise an overflow error validateJSON() fails 1`] = `"should be a multiple of 0.123456789 but is 1e+308 instead"`;

exports[`tests/draft2020-12/not.json collect annotations inside a 'not', even if collection is disabled outputFormat = verbose, failFast = false annotations are still collected inside a 'not' validateJSON() fails 1`] = `"validates against a subschema that is not allowed"`;

exports[`tests/draft2020-12/not.json collect annotations inside a 'not', even if collection is disabled outputFormat = verbose, failFast = true annotations are still collected inside a 'not' validateJSON() fails 1`] = `"validates against a subschema that is not allowed"`;

exports[`tests/draft2020-12/not.json forbidden property outputFormat = verbose, failFast = false property present validateJSON() fails 1`] = `"has an invalid property foo (validates against a subschema that is not allowed)"`;

exports[`tests/draft2020-12/not.json forbidden property outputFormat = verbose, failFast = true property present validateJSON() fails 1`] = `"has an invalid property (foo validates against a subschema that is not allowed)"`;

exports[`tests/draft2020-12/not.json not more complex schema outputFormat = verbose, failFast = false mismatch validateJSON() fails 1`] = `"validates against a subschema that is not allowed"`;

exports[`tests/draft2020-12/not.json not more complex schema outputFormat = verbose, failFast = true mismatch validateJSON() fails 1`] = `"validates against a subschema that is not allowed"`;

exports[`tests/draft2020-12/not.json not multiple types outputFormat = verbose, failFast = false mismatch validateJSON() fails 1`] = `"validates against a subschema that is not allowed"`;

exports[`tests/draft2020-12/not.json not multiple types outputFormat = verbose, failFast = false other mismatch validateJSON() fails 1`] = `"validates against a subschema that is not allowed"`;

exports[`tests/draft2020-12/not.json not multiple types outputFormat = verbose, failFast = true mismatch validateJSON() fails 1`] = `"validates against a subschema that is not allowed"`;

exports[`tests/draft2020-12/not.json not multiple types outputFormat = verbose, failFast = true other mismatch validateJSON() fails 1`] = `"validates against a subschema that is not allowed"`;

exports[`tests/draft2020-12/not.json not outputFormat = verbose, failFast = false disallowed validateJSON() fails 1`] = `"validates against a subschema that is not allowed"`;

exports[`tests/draft2020-12/not.json not outputFormat = verbose, failFast = true disallowed validateJSON() fails 1`] = `"validates against a subschema that is not allowed"`;

exports[`tests/draft2020-12/not.json not with boolean schema true outputFormat = verbose, failFast = false any value is invalid validateJSON() fails 1`] = `"validates against a subschema that is not allowed"`;

exports[`tests/draft2020-12/not.json not with boolean schema true outputFormat = verbose, failFast = true any value is invalid validateJSON() fails 1`] = `"validates against a subschema that is not allowed"`;

exports[`tests/draft2020-12/oneOf.json nested oneOf, to check validation semantics outputFormat = verbose, failFast = false anything non-null is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/oneOf.json nested oneOf, to check validation semantics outputFormat = verbose, failFast = true anything non-null is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/oneOf.json oneOf complex types outputFormat = verbose, failFast = false both oneOf valid (complex) validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf complex types outputFormat = verbose, failFast = false neither oneOf valid (complex) validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/oneOf.json oneOf complex types outputFormat = verbose, failFast = true both oneOf valid (complex) validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf complex types outputFormat = verbose, failFast = true neither oneOf valid (complex) validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/oneOf.json oneOf outputFormat = verbose, failFast = false both oneOf valid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf outputFormat = verbose, failFast = false neither oneOf valid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/oneOf.json oneOf outputFormat = verbose, failFast = true both oneOf valid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf outputFormat = verbose, failFast = true neither oneOf valid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/oneOf.json oneOf with base schema outputFormat = verbose, failFast = false both oneOf valid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf with base schema outputFormat = verbose, failFast = false mismatch base schema validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2; should be a string but is an integer instead"`;

exports[`tests/draft2020-12/oneOf.json oneOf with base schema outputFormat = verbose, failFast = true both oneOf valid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf with base schema outputFormat = verbose, failFast = true mismatch base schema validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf with boolean schemas, all false outputFormat = verbose, failFast = false any value is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/oneOf.json oneOf with boolean schemas, all false outputFormat = verbose, failFast = true any value is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/oneOf.json oneOf with boolean schemas, all true outputFormat = verbose, failFast = false any value is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 3"`;

exports[`tests/draft2020-12/oneOf.json oneOf with boolean schemas, all true outputFormat = verbose, failFast = true any value is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 3"`;

exports[`tests/draft2020-12/oneOf.json oneOf with boolean schemas, more than one true outputFormat = verbose, failFast = false any value is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf with boolean schemas, more than one true outputFormat = verbose, failFast = true any value is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf with empty schema outputFormat = verbose, failFast = false both valid - invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf with empty schema outputFormat = verbose, failFast = true both valid - invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf with missing optional property outputFormat = verbose, failFast = false both oneOf valid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf with missing optional property outputFormat = verbose, failFast = false neither oneOf valid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/oneOf.json oneOf with missing optional property outputFormat = verbose, failFast = true both oneOf valid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf with missing optional property outputFormat = verbose, failFast = true neither oneOf valid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/oneOf.json oneOf with required outputFormat = verbose, failFast = false both invalid - invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/oneOf.json oneOf with required outputFormat = verbose, failFast = false both valid - invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/oneOf.json oneOf with required outputFormat = verbose, failFast = true both invalid - invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/oneOf.json oneOf with required outputFormat = verbose, failFast = true both valid - invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/pattern.json pattern validation outputFormat = verbose, failFast = false a non-matching pattern is invalid validateJSON() fails 1`] = `"should match '^a*$' but is 'abc' instead"`;

exports[`tests/draft2020-12/pattern.json pattern validation outputFormat = verbose, failFast = true a non-matching pattern is invalid validateJSON() fails 1`] = `"should match '^a*$' but is 'abc' instead"`;

exports[`tests/draft2020-12/patternProperties.json multiple simultaneous patternProperties are validated outputFormat = verbose, failFast = false an invalid due to both is invalid validateJSON() fails 1`] = `"has invalid properties 'aaa' and 'aaaa' (should be an integer but is a string instead; should be less than or equal to 20 but is 31 instead)"`;

exports[`tests/draft2020-12/patternProperties.json multiple simultaneous patternProperties are validated outputFormat = verbose, failFast = false an invalid due to one is invalid validateJSON() fails 1`] = `"has an invalid property a (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/patternProperties.json multiple simultaneous patternProperties are validated outputFormat = verbose, failFast = false an invalid due to the other is invalid validateJSON() fails 1`] = `"has an invalid property aaaa (should be less than or equal to 20 but is 31 instead)"`;

exports[`tests/draft2020-12/patternProperties.json multiple simultaneous patternProperties are validated outputFormat = verbose, failFast = true an invalid due to both is invalid validateJSON() fails 1`] = `"has an invalid property aaa (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/patternProperties.json multiple simultaneous patternProperties are validated outputFormat = verbose, failFast = true an invalid due to one is invalid validateJSON() fails 1`] = `"has an invalid property a (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/patternProperties.json multiple simultaneous patternProperties are validated outputFormat = verbose, failFast = true an invalid due to the other is invalid validateJSON() fails 1`] = `"has an invalid property aaaa (should be less than or equal to 20 but is 31 instead)"`;

exports[`tests/draft2020-12/patternProperties.json patternProperties validates properties matching a regex outputFormat = verbose, failFast = false a single invalid match is invalid validateJSON() fails 1`] = `"has an invalid property foo (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/patternProperties.json patternProperties validates properties matching a regex outputFormat = verbose, failFast = false multiple invalid matches is invalid validateJSON() fails 1`] = `"has invalid properties 'foo' and 'foooooo' (should be an integer but is a string instead; should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/patternProperties.json patternProperties validates properties matching a regex outputFormat = verbose, failFast = true a single invalid match is invalid validateJSON() fails 1`] = `"has an invalid property foo (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/patternProperties.json patternProperties validates properties matching a regex outputFormat = verbose, failFast = true multiple invalid matches is invalid validateJSON() fails 1`] = `"has an invalid property foo (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/patternProperties.json patternProperties with boolean schemas outputFormat = verbose, failFast = false object with a property matching both true and false is invalid validateJSON() fails 1`] = `"has an invalid property foobar (should not be defined but is 1)"`;

exports[`tests/draft2020-12/patternProperties.json patternProperties with boolean schemas outputFormat = verbose, failFast = false object with both properties is invalid validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 2)"`;

exports[`tests/draft2020-12/patternProperties.json patternProperties with boolean schemas outputFormat = verbose, failFast = false object with property matching schema false is invalid validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 2)"`;

exports[`tests/draft2020-12/patternProperties.json patternProperties with boolean schemas outputFormat = verbose, failFast = true object with a property matching both true and false is invalid validateJSON() fails 1`] = `"has an invalid property foobar (should not be defined but is 1)"`;

exports[`tests/draft2020-12/patternProperties.json patternProperties with boolean schemas outputFormat = verbose, failFast = true object with both properties is invalid validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 2)"`;

exports[`tests/draft2020-12/patternProperties.json patternProperties with boolean schemas outputFormat = verbose, failFast = true object with property matching schema false is invalid validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 2)"`;

exports[`tests/draft2020-12/patternProperties.json regexes are not anchored by default and are case sensitive outputFormat = verbose, failFast = false recognized members are accounted for validateJSON() fails 1`] = `"has an invalid property a31b (should be a boolean but is null instead)"`;

exports[`tests/draft2020-12/patternProperties.json regexes are not anchored by default and are case sensitive outputFormat = verbose, failFast = false regexes are case sensitive, 2 validateJSON() fails 1`] = `"has an invalid property a_X_3 (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/patternProperties.json regexes are not anchored by default and are case sensitive outputFormat = verbose, failFast = true recognized members are accounted for validateJSON() fails 1`] = `"has an invalid property a31b (should be a boolean but is null instead)"`;

exports[`tests/draft2020-12/patternProperties.json regexes are not anchored by default and are case sensitive outputFormat = verbose, failFast = true regexes are case sensitive, 2 validateJSON() fails 1`] = `"has an invalid property a_X_3 (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/prefixItems.json a schema given for prefixItems outputFormat = verbose, failFast = false wrong types validateJSON() fails 1`] = `"has invalid items at positions 0 and 1 (should be an integer but is a string instead; should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/prefixItems.json a schema given for prefixItems outputFormat = verbose, failFast = true wrong types validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/prefixItems.json prefixItems with boolean schemas outputFormat = verbose, failFast = false array with two items is invalid validateJSON() fails 1`] = `"has an invalid item at position 1 (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/prefixItems.json prefixItems with boolean schemas outputFormat = verbose, failFast = true array with two items is invalid validateJSON() fails 1`] = `"should not be defined but is 'foo'"`;

exports[`tests/draft2020-12/properties.json object properties validation outputFormat = verbose, failFast = false both properties invalid is invalid validateJSON() fails 1`] = `"has invalid properties 'foo' and 'bar' (should be an integer but is an array instead; should be a string but is an object instead)"`;

exports[`tests/draft2020-12/properties.json object properties validation outputFormat = verbose, failFast = false one property invalid is invalid validateJSON() fails 1`] = `"has an invalid property bar (should be a string but is an object instead)"`;

exports[`tests/draft2020-12/properties.json object properties validation outputFormat = verbose, failFast = true both properties invalid is invalid validateJSON() fails 1`] = `"has an invalid property (foo should be an integer but is an array instead)"`;

exports[`tests/draft2020-12/properties.json object properties validation outputFormat = verbose, failFast = true one property invalid is invalid validateJSON() fails 1`] = `"has an invalid property (bar should be a string but is an object instead)"`;

exports[`tests/draft2020-12/properties.json properties whose names are Javascript object property names outputFormat = verbose, failFast = false __proto__ not valid validateJSON() fails 1`] = `"has an invalid property __proto__ (should be a number but is a string instead)"`;

exports[`tests/draft2020-12/properties.json properties whose names are Javascript object property names outputFormat = verbose, failFast = false constructor not valid validateJSON() fails 1`] = `"has an invalid property constructor (should be a number but is an object instead)"`;

exports[`tests/draft2020-12/properties.json properties whose names are Javascript object property names outputFormat = verbose, failFast = false toString not valid validateJSON() fails 1`] = `"has an invalid property toString (has an invalid property length (should be a string but is an integer instead))"`;

exports[`tests/draft2020-12/properties.json properties whose names are Javascript object property names outputFormat = verbose, failFast = true __proto__ not valid validateJSON() fails 1`] = `"has an invalid property (__proto__ should be a number but is a string instead)"`;

exports[`tests/draft2020-12/properties.json properties whose names are Javascript object property names outputFormat = verbose, failFast = true constructor not valid validateJSON() fails 1`] = `"has an invalid property (constructor should be a number but is an object instead)"`;

exports[`tests/draft2020-12/properties.json properties whose names are Javascript object property names outputFormat = verbose, failFast = true toString not valid validateJSON() fails 1`] = `"has an invalid property (toString has an invalid property (length should be a string but is an integer instead))"`;

exports[`tests/draft2020-12/properties.json properties with boolean schema outputFormat = verbose, failFast = false both properties present is invalid validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 2)"`;

exports[`tests/draft2020-12/properties.json properties with boolean schema outputFormat = verbose, failFast = false only 'false' property present is invalid validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 2)"`;

exports[`tests/draft2020-12/properties.json properties with boolean schema outputFormat = verbose, failFast = true both properties present is invalid validateJSON() fails 1`] = `"has an invalid property (bar should not be defined but is 2)"`;

exports[`tests/draft2020-12/properties.json properties with boolean schema outputFormat = verbose, failFast = true only 'false' property present is invalid validateJSON() fails 1`] = `"has an invalid property (bar should not be defined but is 2)"`;

exports[`tests/draft2020-12/properties.json properties with escaped characters outputFormat = verbose, failFast = false object with strings is invalid validateJSON() fails 1`] = `
"has invalid properties 'foo
bar', 'foo"bar', 'foo\\bar', 'foo
bar', 'foo	bar' and 'foobar' (should be a number but is a string instead; should be a number but is a string instead; should be a number but is a string instead; should be a number but is a string instead; should be a number but is a string instead; should be a number but is a string instead)"
`;

exports[`tests/draft2020-12/properties.json properties with escaped characters outputFormat = verbose, failFast = true object with strings is invalid validateJSON() fails 1`] = `
"has an invalid property (foo
bar should be a number but is a string instead)"
`;

exports[`tests/draft2020-12/properties.json properties, patternProperties, additionalProperties interaction outputFormat = verbose, failFast = false additionalProperty invalidates others validateJSON() fails 1`] = `"has an invalid property quux (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/properties.json properties, patternProperties, additionalProperties interaction outputFormat = verbose, failFast = false patternProperty invalidates nonproperty validateJSON() fails 1`] = `"has an invalid property fxo (should have at least 2 items but has 0 instead)"`;

exports[`tests/draft2020-12/properties.json properties, patternProperties, additionalProperties interaction outputFormat = verbose, failFast = false patternProperty invalidates property validateJSON() fails 1`] = `"has an invalid property foo (should have at least 2 items but has 0 instead)"`;

exports[`tests/draft2020-12/properties.json properties, patternProperties, additionalProperties interaction outputFormat = verbose, failFast = false property invalidates property validateJSON() fails 1`] = `"has an invalid property foo (should have up to 3 items but has 4 instead)"`;

exports[`tests/draft2020-12/properties.json properties, patternProperties, additionalProperties interaction outputFormat = verbose, failFast = true additionalProperty invalidates others validateJSON() fails 1`] = `"has an invalid property quux (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/properties.json properties, patternProperties, additionalProperties interaction outputFormat = verbose, failFast = true patternProperty invalidates nonproperty validateJSON() fails 1`] = `"has an invalid property fxo (should have at least 2 items but has 0 instead)"`;

exports[`tests/draft2020-12/properties.json properties, patternProperties, additionalProperties interaction outputFormat = verbose, failFast = true patternProperty invalidates property validateJSON() fails 1`] = `"has an invalid property foo (should have at least 2 items but has 0 instead)"`;

exports[`tests/draft2020-12/properties.json properties, patternProperties, additionalProperties interaction outputFormat = verbose, failFast = true property invalidates property validateJSON() fails 1`] = `"has an invalid property (foo should have up to 3 items but has 4 instead)"`;

exports[`tests/draft2020-12/propertyNames.json propertyNames validation outputFormat = verbose, failFast = false some property names invalid validateJSON() fails 1`] = `"has an invalid property name foobar (should have up to 3 characters but has 6 instead)"`;

exports[`tests/draft2020-12/propertyNames.json propertyNames validation outputFormat = verbose, failFast = true some property names invalid validateJSON() fails 1`] = `"has an invalid property name foobar (should have up to 3 characters but has 6 instead)"`;

exports[`tests/draft2020-12/propertyNames.json propertyNames with boolean schema false outputFormat = verbose, failFast = false object with any properties is invalid validateJSON() fails 1`] = `"has an invalid property name foo (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/propertyNames.json propertyNames with boolean schema false outputFormat = verbose, failFast = true object with any properties is invalid validateJSON() fails 1`] = `"has an invalid property name foo (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/ref.json $id must be resolved against nearest parent, not just immediate parent outputFormat = verbose, failFast = false non-number is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/ref.json $id must be resolved against nearest parent, not just immediate parent outputFormat = verbose, failFast = true non-number is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/ref.json $id with file URI still resolves pointers - *nix outputFormat = verbose, failFast = false non-number is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/ref.json $id with file URI still resolves pointers - *nix outputFormat = verbose, failFast = true non-number is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/ref.json $id with file URI still resolves pointers - windows outputFormat = verbose, failFast = false non-number is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/ref.json $id with file URI still resolves pointers - windows outputFormat = verbose, failFast = true non-number is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/ref.json $ref to boolean schema false outputFormat = verbose, failFast = false any value is invalid validateJSON() fails 1`] = `"should not be defined but is 'foo'"`;

exports[`tests/draft2020-12/ref.json $ref to boolean schema false outputFormat = verbose, failFast = true any value is invalid validateJSON() fails 1`] = `"should not be defined but is 'foo'"`;

exports[`tests/draft2020-12/ref.json Recursive references between schemas outputFormat = verbose, failFast = false invalid tree validateJSON() fails 1`] = `"has an invalid property nodes (has an invalid item at position 0 (has an invalid property subtree (has an invalid property nodes (has an invalid item at position 0 (has an invalid property value (should be a number but is a string instead))))))"`;

exports[`tests/draft2020-12/ref.json Recursive references between schemas outputFormat = verbose, failFast = true invalid tree validateJSON() fails 1`] = `"has an invalid property (nodes has an invalid property (subtree has an invalid property (nodes has an invalid property (value should be a number but is a string instead))))"`;

exports[`tests/draft2020-12/ref.json URN base URI with NSS outputFormat = verbose, failFast = false a non-string is invalid validateJSON() fails 1`] = `"has an invalid property foo (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json URN base URI with NSS outputFormat = verbose, failFast = true a non-string is invalid validateJSON() fails 1`] = `"has an invalid property (foo should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json URN base URI with URN and JSON pointer ref outputFormat = verbose, failFast = false a non-string is invalid validateJSON() fails 1`] = `"has an invalid property foo (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json URN base URI with URN and JSON pointer ref outputFormat = verbose, failFast = true a non-string is invalid validateJSON() fails 1`] = `"has an invalid property (foo should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json URN base URI with URN and anchor ref outputFormat = verbose, failFast = false a non-string is invalid validateJSON() fails 1`] = `"has an invalid property foo (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json URN base URI with URN and anchor ref outputFormat = verbose, failFast = true a non-string is invalid validateJSON() fails 1`] = `"has an invalid property (foo should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json URN base URI with f-component outputFormat = verbose, failFast = false is invalid validateJSON() fails 1`] = `"has an invalid property $id (should match '^[^#]*#?$' but is 'urn:example:foo-bar-baz-qux#somepart' instead)"`;

exports[`tests/draft2020-12/ref.json URN base URI with f-component outputFormat = verbose, failFast = true is invalid validateJSON() fails 1`] = `"has an invalid property ($id should match '^[^#]*#?$' but is 'urn:example:foo-bar-baz-qux#somepart' instead)"`;

exports[`tests/draft2020-12/ref.json URN base URI with q-component outputFormat = verbose, failFast = false a non-string is invalid validateJSON() fails 1`] = `"has an invalid property foo (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json URN base URI with q-component outputFormat = verbose, failFast = true a non-string is invalid validateJSON() fails 1`] = `"has an invalid property (foo should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json URN base URI with r-component outputFormat = verbose, failFast = false a non-string is invalid validateJSON() fails 1`] = `"has an invalid property foo (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json URN base URI with r-component outputFormat = verbose, failFast = true a non-string is invalid validateJSON() fails 1`] = `"has an invalid property (foo should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json URN ref with nested pointer ref outputFormat = verbose, failFast = false a non-string is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/ref.json URN ref with nested pointer ref outputFormat = verbose, failFast = true a non-string is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/ref.json empty tokens in $ref json-pointer outputFormat = verbose, failFast = false non-number is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/ref.json empty tokens in $ref json-pointer outputFormat = verbose, failFast = true non-number is invalid validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/ref.json escaped pointer ref outputFormat = verbose, failFast = false percent invalid validateJSON() fails 1`] = `"has an invalid property percent (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/ref.json escaped pointer ref outputFormat = verbose, failFast = false slash invalid validateJSON() fails 1`] = `"has an invalid property slash (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/ref.json escaped pointer ref outputFormat = verbose, failFast = false tilde invalid validateJSON() fails 1`] = `"has an invalid property tilde (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/ref.json escaped pointer ref outputFormat = verbose, failFast = true percent invalid validateJSON() fails 1`] = `"has an invalid property (percent should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/ref.json escaped pointer ref outputFormat = verbose, failFast = true slash invalid validateJSON() fails 1`] = `"has an invalid property (slash should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/ref.json escaped pointer ref outputFormat = verbose, failFast = true tilde invalid validateJSON() fails 1`] = `"has an invalid property (tilde should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/ref.json naive replacement of $ref with its destination is not correct outputFormat = verbose, failFast = false do not evaluate the $ref inside the enum, definition exact match validateJSON() fails 1`] = `"should be {"$ref":"#/$defs/a_string"} but is {"type":"string"} instead"`;

exports[`tests/draft2020-12/ref.json naive replacement of $ref with its destination is not correct outputFormat = verbose, failFast = false do not evaluate the $ref inside the enum, matching any string validateJSON() fails 1`] = `"should be {"$ref":"#/$defs/a_string"} but is 'this is a string' instead"`;

exports[`tests/draft2020-12/ref.json naive replacement of $ref with its destination is not correct outputFormat = verbose, failFast = true do not evaluate the $ref inside the enum, definition exact match validateJSON() fails 1`] = `"should be {"$ref":"#/$defs/a_string"} but is {"type":"string"} instead"`;

exports[`tests/draft2020-12/ref.json naive replacement of $ref with its destination is not correct outputFormat = verbose, failFast = true do not evaluate the $ref inside the enum, matching any string validateJSON() fails 1`] = `"should be {"$ref":"#/$defs/a_string"} but is 'this is a string' instead"`;

exports[`tests/draft2020-12/ref.json nested refs outputFormat = verbose, failFast = false nested ref invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/ref.json nested refs outputFormat = verbose, failFast = true nested ref invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/ref.json order of evaluation: $id and $anchor and $ref outputFormat = verbose, failFast = false data is invalid against first definition validateJSON() fails 1`] = `"should be less than or equal to 10 but is 50 instead"`;

exports[`tests/draft2020-12/ref.json order of evaluation: $id and $anchor and $ref outputFormat = verbose, failFast = true data is invalid against first definition validateJSON() fails 1`] = `"should be less than or equal to 10 but is 50 instead"`;

exports[`tests/draft2020-12/ref.json order of evaluation: $id and $ref outputFormat = verbose, failFast = false data is invalid against first definition validateJSON() fails 1`] = `"should be less than or equal to 10 but is 50 instead"`;

exports[`tests/draft2020-12/ref.json order of evaluation: $id and $ref outputFormat = verbose, failFast = true data is invalid against first definition validateJSON() fails 1`] = `"should be less than or equal to 10 but is 50 instead"`;

exports[`tests/draft2020-12/ref.json property named $ref that is not a reference outputFormat = verbose, failFast = false property named $ref invalid validateJSON() fails 1`] = `"has an invalid property $ref (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json property named $ref that is not a reference outputFormat = verbose, failFast = true property named $ref invalid validateJSON() fails 1`] = `"has an invalid property ($ref should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json property named $ref, containing an actual $ref outputFormat = verbose, failFast = false property named $ref invalid validateJSON() fails 1`] = `"has an invalid property $ref (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json property named $ref, containing an actual $ref outputFormat = verbose, failFast = true property named $ref invalid validateJSON() fails 1`] = `"has an invalid property ($ref should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json ref applies alongside sibling keywords outputFormat = verbose, failFast = false ref invalid validateJSON() fails 1`] = `"has an invalid property foo (should be an array but is a string instead)"`;

exports[`tests/draft2020-12/ref.json ref applies alongside sibling keywords outputFormat = verbose, failFast = false ref valid, maxItems invalid validateJSON() fails 1`] = `"has an invalid property foo (should have up to 2 items but has 3 instead)"`;

exports[`tests/draft2020-12/ref.json ref applies alongside sibling keywords outputFormat = verbose, failFast = true ref invalid validateJSON() fails 1`] = `"has an invalid property (foo should be an array but is a string instead)"`;

exports[`tests/draft2020-12/ref.json ref applies alongside sibling keywords outputFormat = verbose, failFast = true ref valid, maxItems invalid validateJSON() fails 1`] = `"has an invalid property (foo should have up to 2 items but has 3 instead)"`;

exports[`tests/draft2020-12/ref.json ref creates new scope when adjacent to keywords outputFormat = verbose, failFast = false referenced subschema doesn't see annotations from properties validateJSON() fails 1`] = `"has an invalid property prop1 (should not be defined but is 'match')"`;

exports[`tests/draft2020-12/ref.json ref creates new scope when adjacent to keywords outputFormat = verbose, failFast = true referenced subschema doesn't see annotations from properties validateJSON() fails 1`] = `"has an invalid property prop1 (should not be defined but is 'match')"`;

exports[`tests/draft2020-12/ref.json ref to else outputFormat = verbose, failFast = false a non-integer is invalid due to the $ref validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/ref.json ref to else outputFormat = verbose, failFast = true a non-integer is invalid due to the $ref validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/ref.json ref to if outputFormat = verbose, failFast = false a non-integer is invalid due to the $ref validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/ref.json ref to if outputFormat = verbose, failFast = true a non-integer is invalid due to the $ref validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/ref.json ref to then outputFormat = verbose, failFast = false a non-integer is invalid due to the $ref validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/ref.json ref to then outputFormat = verbose, failFast = true a non-integer is invalid due to the $ref validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/ref.json ref with absolute-path-reference outputFormat = verbose, failFast = false an integer is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/ref.json ref with absolute-path-reference outputFormat = verbose, failFast = true an integer is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/ref.json refs with quote outputFormat = verbose, failFast = false object with strings is invalid validateJSON() fails 1`] = `"has an invalid property foo"bar (should be a number but is a string instead)"`;

exports[`tests/draft2020-12/ref.json refs with quote outputFormat = verbose, failFast = true object with strings is invalid validateJSON() fails 1`] = `"has an invalid property (foo"bar should be a number but is a string instead)"`;

exports[`tests/draft2020-12/ref.json refs with relative uris and defs outputFormat = verbose, failFast = false invalid on inner field validateJSON() fails 1`] = `"has an invalid property foo (has an invalid property bar (should be a string but is an integer instead))"`;

exports[`tests/draft2020-12/ref.json refs with relative uris and defs outputFormat = verbose, failFast = false invalid on outer field validateJSON() fails 1`] = `"has an invalid property bar (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json refs with relative uris and defs outputFormat = verbose, failFast = true invalid on inner field validateJSON() fails 1`] = `"has an invalid property (foo has an invalid property (bar should be a string but is an integer instead))"`;

exports[`tests/draft2020-12/ref.json refs with relative uris and defs outputFormat = verbose, failFast = true invalid on outer field validateJSON() fails 1`] = `"has an invalid property (bar should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json relative pointer ref to array outputFormat = verbose, failFast = false mismatch array validateJSON() fails 1`] = `"has an invalid item at position 1 (should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/ref.json relative pointer ref to array outputFormat = verbose, failFast = true mismatch array validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/ref.json relative pointer ref to object outputFormat = verbose, failFast = false mismatch validateJSON() fails 1`] = `"has an invalid property bar (should be an integer but is a boolean instead)"`;

exports[`tests/draft2020-12/ref.json relative pointer ref to object outputFormat = verbose, failFast = true mismatch validateJSON() fails 1`] = `"has an invalid property (bar should be an integer but is a boolean instead)"`;

exports[`tests/draft2020-12/ref.json relative refs with absolute uris and defs outputFormat = verbose, failFast = false invalid on inner field validateJSON() fails 1`] = `"has an invalid property foo (has an invalid property bar (should be a string but is an integer instead))"`;

exports[`tests/draft2020-12/ref.json relative refs with absolute uris and defs outputFormat = verbose, failFast = false invalid on outer field validateJSON() fails 1`] = `"has an invalid property bar (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json relative refs with absolute uris and defs outputFormat = verbose, failFast = true invalid on inner field validateJSON() fails 1`] = `"has an invalid property (foo has an invalid property (bar should be a string but is an integer instead))"`;

exports[`tests/draft2020-12/ref.json relative refs with absolute uris and defs outputFormat = verbose, failFast = true invalid on outer field validateJSON() fails 1`] = `"has an invalid property (bar should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json remote ref, containing refs itself outputFormat = verbose, failFast = false remote ref invalid validateJSON() fails 1`] = `"has an invalid property minLength (should be greater than or equal to 0 but is -1 instead)"`;

exports[`tests/draft2020-12/ref.json remote ref, containing refs itself outputFormat = verbose, failFast = true remote ref invalid validateJSON() fails 1`] = `"has an invalid property (minLength should be greater than or equal to 0 but is -1 instead)"`;

exports[`tests/draft2020-12/ref.json root pointer ref outputFormat = verbose, failFast = false mismatch validateJSON() fails 1`] = `"has an invalid property bar"`;

exports[`tests/draft2020-12/ref.json root pointer ref outputFormat = verbose, failFast = false recursive mismatch validateJSON() fails 1`] = `"has an invalid property foo (has an invalid property bar)"`;

exports[`tests/draft2020-12/ref.json root pointer ref outputFormat = verbose, failFast = true mismatch validateJSON() fails 1`] = `"has a disallowed additional property ('bar')"`;

exports[`tests/draft2020-12/ref.json root pointer ref outputFormat = verbose, failFast = true recursive mismatch validateJSON() fails 1`] = `"has an invalid property (foo has a disallowed additional property ('bar'))"`;

exports[`tests/draft2020-12/ref.json simple URN base URI with $ref via the URN outputFormat = verbose, failFast = false invalid under the URN IDed schema validateJSON() fails 1`] = `"has an invalid property foo (should be greater than or equal to 30 but is 12 instead)"`;

exports[`tests/draft2020-12/ref.json simple URN base URI with $ref via the URN outputFormat = verbose, failFast = true invalid under the URN IDed schema validateJSON() fails 1`] = `"has an invalid property (foo should be greater than or equal to 30 but is 12 instead)"`;

exports[`tests/draft2020-12/ref.json simple URN base URI with JSON pointer outputFormat = verbose, failFast = false a non-string is invalid validateJSON() fails 1`] = `"has an invalid property foo (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/ref.json simple URN base URI with JSON pointer outputFormat = verbose, failFast = true a non-string is invalid validateJSON() fails 1`] = `"has an invalid property (foo should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/refRemote.json $ref to $ref finds detached $anchor outputFormat = verbose, failFast = false non-number is invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json $ref to $ref finds detached $anchor outputFormat = verbose, failFast = true non-number is invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json Location-independent identifier in remote ref outputFormat = verbose, failFast = false string is invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json Location-independent identifier in remote ref outputFormat = verbose, failFast = true string is invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json anchor within remote ref outputFormat = verbose, failFast = false remote anchor invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json anchor within remote ref outputFormat = verbose, failFast = true remote anchor invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json base URI change - change folder in subschema outputFormat = verbose, failFast = false string is invalid validateJSON() fails 1`] = `"has an invalid property list (has an invalid item at position 0 (should be an integer but is a string instead))"`;

exports[`tests/draft2020-12/refRemote.json base URI change - change folder in subschema outputFormat = verbose, failFast = true string is invalid validateJSON() fails 1`] = `"has an invalid property (list should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/refRemote.json base URI change - change folder outputFormat = verbose, failFast = false string is invalid validateJSON() fails 1`] = `"has an invalid property list (has an invalid item at position 0 (should be an integer but is a string instead))"`;

exports[`tests/draft2020-12/refRemote.json base URI change - change folder outputFormat = verbose, failFast = true string is invalid validateJSON() fails 1`] = `"has an invalid property (list should be an integer but is a string instead)"`;

exports[`tests/draft2020-12/refRemote.json base URI change outputFormat = verbose, failFast = false base URI change ref invalid validateJSON() fails 1`] = `"has an invalid item at position 0 (has an invalid item at position 0 (should be an integer but is a string instead))"`;

exports[`tests/draft2020-12/refRemote.json base URI change outputFormat = verbose, failFast = true base URI change ref invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json fragment within remote ref outputFormat = verbose, failFast = false remote fragment invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json fragment within remote ref outputFormat = verbose, failFast = true remote fragment invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json ref within remote ref outputFormat = verbose, failFast = false ref within ref invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json ref within remote ref outputFormat = verbose, failFast = true ref within ref invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json remote HTTP ref with different $id outputFormat = verbose, failFast = false number is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/refRemote.json remote HTTP ref with different $id outputFormat = verbose, failFast = true number is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/refRemote.json remote HTTP ref with different URN $id outputFormat = verbose, failFast = false number is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/refRemote.json remote HTTP ref with different URN $id outputFormat = verbose, failFast = true number is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/refRemote.json remote HTTP ref with nested absolute ref outputFormat = verbose, failFast = false number is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/refRemote.json remote HTTP ref with nested absolute ref outputFormat = verbose, failFast = true number is invalid validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/refRemote.json remote ref outputFormat = verbose, failFast = false remote ref invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json remote ref outputFormat = verbose, failFast = true remote ref invalid validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/refRemote.json remote ref with ref to defs outputFormat = verbose, failFast = false invalid validateJSON() fails 1`] = `"has an invalid property bar (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/refRemote.json remote ref with ref to defs outputFormat = verbose, failFast = true invalid validateJSON() fails 1`] = `"has an invalid property (bar should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/refRemote.json retrieved nested refs resolve relative to their URI not $id outputFormat = verbose, failFast = false number is invalid validateJSON() fails 1`] = `"has an invalid property name (has an invalid property foo (should be a string but is an integer instead))"`;

exports[`tests/draft2020-12/refRemote.json retrieved nested refs resolve relative to their URI not $id outputFormat = verbose, failFast = true number is invalid validateJSON() fails 1`] = `"has an invalid property (name has an invalid property (foo should be a string but is an integer instead))"`;

exports[`tests/draft2020-12/refRemote.json root ref in remote ref outputFormat = verbose, failFast = false object is invalid validateJSON() fails 1`] = `"has an invalid property name (does not validate against any subschema)"`;

exports[`tests/draft2020-12/refRemote.json root ref in remote ref outputFormat = verbose, failFast = true object is invalid validateJSON() fails 1`] = `"has an invalid property (name does not validate against any subschema)"`;

exports[`tests/draft2020-12/required.json required properties whose names are Javascript object property names outputFormat = verbose, failFast = false __proto__ present validateJSON() fails 1`] = `"is missing 'toString' and 'constructor'"`;

exports[`tests/draft2020-12/required.json required properties whose names are Javascript object property names outputFormat = verbose, failFast = false constructor present validateJSON() fails 1`] = `"is missing '__proto__' and 'toString'"`;

exports[`tests/draft2020-12/required.json required properties whose names are Javascript object property names outputFormat = verbose, failFast = false none of the properties mentioned validateJSON() fails 1`] = `"is missing '__proto__', 'toString' and 'constructor'"`;

exports[`tests/draft2020-12/required.json required properties whose names are Javascript object property names outputFormat = verbose, failFast = false toString present validateJSON() fails 1`] = `"is missing '__proto__' and 'constructor'"`;

exports[`tests/draft2020-12/required.json required properties whose names are Javascript object property names outputFormat = verbose, failFast = true __proto__ present validateJSON() fails 1`] = `"is missing 'toString' and 'constructor'"`;

exports[`tests/draft2020-12/required.json required properties whose names are Javascript object property names outputFormat = verbose, failFast = true constructor present validateJSON() fails 1`] = `"is missing '__proto__' and 'toString'"`;

exports[`tests/draft2020-12/required.json required properties whose names are Javascript object property names outputFormat = verbose, failFast = true none of the properties mentioned validateJSON() fails 1`] = `"is missing '__proto__', 'toString' and 'constructor'"`;

exports[`tests/draft2020-12/required.json required properties whose names are Javascript object property names outputFormat = verbose, failFast = true toString present validateJSON() fails 1`] = `"is missing '__proto__' and 'constructor'"`;

exports[`tests/draft2020-12/required.json required validation outputFormat = verbose, failFast = false non-present required property is invalid validateJSON() fails 1`] = `"is missing 'foo'"`;

exports[`tests/draft2020-12/required.json required validation outputFormat = verbose, failFast = true non-present required property is invalid validateJSON() fails 1`] = `"is missing 'foo'"`;

exports[`tests/draft2020-12/required.json required with escaped characters outputFormat = verbose, failFast = false object with some properties missing is invalid validateJSON() fails 1`] = `
"is missing 'foo\\bar', 'foo
bar', 'foo	bar' and 'foobar'"
`;

exports[`tests/draft2020-12/required.json required with escaped characters outputFormat = verbose, failFast = true object with some properties missing is invalid validateJSON() fails 1`] = `
"is missing 'foo\\bar', 'foo
bar', 'foo	bar' and 'foobar'"
`;

exports[`tests/draft2020-12/type.json array type matches arrays outputFormat = verbose, failFast = false a boolean is not an array validateJSON() fails 1`] = `"should be an array but is a boolean instead"`;

exports[`tests/draft2020-12/type.json array type matches arrays outputFormat = verbose, failFast = false a float is not an array validateJSON() fails 1`] = `"should be an array but is a number instead"`;

exports[`tests/draft2020-12/type.json array type matches arrays outputFormat = verbose, failFast = false a string is not an array validateJSON() fails 1`] = `"should be an array but is a string instead"`;

exports[`tests/draft2020-12/type.json array type matches arrays outputFormat = verbose, failFast = false an integer is not an array validateJSON() fails 1`] = `"should be an array but is an integer instead"`;

exports[`tests/draft2020-12/type.json array type matches arrays outputFormat = verbose, failFast = false an object is not an array validateJSON() fails 1`] = `"should be an array but is an object instead"`;

exports[`tests/draft2020-12/type.json array type matches arrays outputFormat = verbose, failFast = false null is not an array validateJSON() fails 1`] = `"should be an array but is null instead"`;

exports[`tests/draft2020-12/type.json array type matches arrays outputFormat = verbose, failFast = true a boolean is not an array validateJSON() fails 1`] = `"should be an array but is a boolean instead"`;

exports[`tests/draft2020-12/type.json array type matches arrays outputFormat = verbose, failFast = true a float is not an array validateJSON() fails 1`] = `"should be an array but is a number instead"`;

exports[`tests/draft2020-12/type.json array type matches arrays outputFormat = verbose, failFast = true a string is not an array validateJSON() fails 1`] = `"should be an array but is a string instead"`;

exports[`tests/draft2020-12/type.json array type matches arrays outputFormat = verbose, failFast = true an integer is not an array validateJSON() fails 1`] = `"should be an array but is an integer instead"`;

exports[`tests/draft2020-12/type.json array type matches arrays outputFormat = verbose, failFast = true an object is not an array validateJSON() fails 1`] = `"should be an array but is an object instead"`;

exports[`tests/draft2020-12/type.json array type matches arrays outputFormat = verbose, failFast = true null is not an array validateJSON() fails 1`] = `"should be an array but is null instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = false a float is not a boolean validateJSON() fails 1`] = `"should be a boolean but is a number instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = false a string is not a boolean validateJSON() fails 1`] = `"should be a boolean but is a string instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = false an array is not a boolean validateJSON() fails 1`] = `"should be a boolean but is an array instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = false an empty string is not a boolean validateJSON() fails 1`] = `"should be a boolean but is a string instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = false an integer is not a boolean validateJSON() fails 1`] = `"should be a boolean but is an integer instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = false an object is not a boolean validateJSON() fails 1`] = `"should be a boolean but is an object instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = false null is not a boolean validateJSON() fails 1`] = `"should be a boolean but is null instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = false zero is not a boolean validateJSON() fails 1`] = `"should be a boolean but is an integer instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = true a float is not a boolean validateJSON() fails 1`] = `"should be a boolean but is a number instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = true a string is not a boolean validateJSON() fails 1`] = `"should be a boolean but is a string instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = true an array is not a boolean validateJSON() fails 1`] = `"should be a boolean but is an array instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = true an empty string is not a boolean validateJSON() fails 1`] = `"should be a boolean but is a string instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = true an integer is not a boolean validateJSON() fails 1`] = `"should be a boolean but is an integer instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = true an object is not a boolean validateJSON() fails 1`] = `"should be a boolean but is an object instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = true null is not a boolean validateJSON() fails 1`] = `"should be a boolean but is null instead"`;

exports[`tests/draft2020-12/type.json boolean type matches booleans outputFormat = verbose, failFast = true zero is not a boolean validateJSON() fails 1`] = `"should be a boolean but is an integer instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = false a boolean is not an integer validateJSON() fails 1`] = `"should be an integer but is a boolean instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = false a float is not an integer validateJSON() fails 1`] = `"should be an integer but is a number instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = false a string is not an integer validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = false a string is still not an integer, even if it looks like one validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = false an array is not an integer validateJSON() fails 1`] = `"should be an integer but is an array instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = false an object is not an integer validateJSON() fails 1`] = `"should be an integer but is an object instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = false null is not an integer validateJSON() fails 1`] = `"should be an integer but is null instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = true a boolean is not an integer validateJSON() fails 1`] = `"should be an integer but is a boolean instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = true a float is not an integer validateJSON() fails 1`] = `"should be an integer but is a number instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = true a string is not an integer validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = true a string is still not an integer, even if it looks like one validateJSON() fails 1`] = `"should be an integer but is a string instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = true an array is not an integer validateJSON() fails 1`] = `"should be an integer but is an array instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = true an object is not an integer validateJSON() fails 1`] = `"should be an integer but is an object instead"`;

exports[`tests/draft2020-12/type.json integer type matches integers outputFormat = verbose, failFast = true null is not an integer validateJSON() fails 1`] = `"should be an integer but is null instead"`;

exports[`tests/draft2020-12/type.json multiple types can be specified in an array outputFormat = verbose, failFast = false a boolean is invalid validateJSON() fails 1`] = `"should be either an integer or a string but is a boolean instead"`;

exports[`tests/draft2020-12/type.json multiple types can be specified in an array outputFormat = verbose, failFast = false a float is invalid validateJSON() fails 1`] = `"should be either an integer or a string but is a number instead"`;

exports[`tests/draft2020-12/type.json multiple types can be specified in an array outputFormat = verbose, failFast = false an array is invalid validateJSON() fails 1`] = `"should be either an integer or a string but is an array instead"`;

exports[`tests/draft2020-12/type.json multiple types can be specified in an array outputFormat = verbose, failFast = false an object is invalid validateJSON() fails 1`] = `"should be either an integer or a string but is an object instead"`;

exports[`tests/draft2020-12/type.json multiple types can be specified in an array outputFormat = verbose, failFast = false null is invalid validateJSON() fails 1`] = `"should be either an integer or a string but is null instead"`;

exports[`tests/draft2020-12/type.json multiple types can be specified in an array outputFormat = verbose, failFast = true a boolean is invalid validateJSON() fails 1`] = `"should be either an integer or a string but is a boolean instead"`;

exports[`tests/draft2020-12/type.json multiple types can be specified in an array outputFormat = verbose, failFast = true a float is invalid validateJSON() fails 1`] = `"should be either an integer or a string but is a number instead"`;

exports[`tests/draft2020-12/type.json multiple types can be specified in an array outputFormat = verbose, failFast = true an array is invalid validateJSON() fails 1`] = `"should be either an integer or a string but is an array instead"`;

exports[`tests/draft2020-12/type.json multiple types can be specified in an array outputFormat = verbose, failFast = true an object is invalid validateJSON() fails 1`] = `"should be either an integer or a string but is an object instead"`;

exports[`tests/draft2020-12/type.json multiple types can be specified in an array outputFormat = verbose, failFast = true null is invalid validateJSON() fails 1`] = `"should be either an integer or a string but is null instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = false a float is not null validateJSON() fails 1`] = `"should be null but is a number instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = false a string is not null validateJSON() fails 1`] = `"should be null but is a string instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = false an array is not null validateJSON() fails 1`] = `"should be null but is an array instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = false an empty string is not null validateJSON() fails 1`] = `"should be null but is a string instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = false an integer is not null validateJSON() fails 1`] = `"should be null but is an integer instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = false an object is not null validateJSON() fails 1`] = `"should be null but is an object instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = false false is not null validateJSON() fails 1`] = `"should be null but is a boolean instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = false true is not null validateJSON() fails 1`] = `"should be null but is a boolean instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = false zero is not null validateJSON() fails 1`] = `"should be null but is an integer instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = true a float is not null validateJSON() fails 1`] = `"should be null but is a number instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = true a string is not null validateJSON() fails 1`] = `"should be null but is a string instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = true an array is not null validateJSON() fails 1`] = `"should be null but is an array instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = true an empty string is not null validateJSON() fails 1`] = `"should be null but is a string instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = true an integer is not null validateJSON() fails 1`] = `"should be null but is an integer instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = true an object is not null validateJSON() fails 1`] = `"should be null but is an object instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = true false is not null validateJSON() fails 1`] = `"should be null but is a boolean instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = true true is not null validateJSON() fails 1`] = `"should be null but is a boolean instead"`;

exports[`tests/draft2020-12/type.json null type matches only the null object outputFormat = verbose, failFast = true zero is not null validateJSON() fails 1`] = `"should be null but is an integer instead"`;

exports[`tests/draft2020-12/type.json number type matches numbers outputFormat = verbose, failFast = false a boolean is not a number validateJSON() fails 1`] = `"should be a number but is a boolean instead"`;

exports[`tests/draft2020-12/type.json number type matches numbers outputFormat = verbose, failFast = false a string is not a number validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/type.json number type matches numbers outputFormat = verbose, failFast = false a string is still not a number, even if it looks like one validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/type.json number type matches numbers outputFormat = verbose, failFast = false an array is not a number validateJSON() fails 1`] = `"should be a number but is an array instead"`;

exports[`tests/draft2020-12/type.json number type matches numbers outputFormat = verbose, failFast = false an object is not a number validateJSON() fails 1`] = `"should be a number but is an object instead"`;

exports[`tests/draft2020-12/type.json number type matches numbers outputFormat = verbose, failFast = false null is not a number validateJSON() fails 1`] = `"should be a number but is null instead"`;

exports[`tests/draft2020-12/type.json number type matches numbers outputFormat = verbose, failFast = true a boolean is not a number validateJSON() fails 1`] = `"should be a number but is a boolean instead"`;

exports[`tests/draft2020-12/type.json number type matches numbers outputFormat = verbose, failFast = true a string is not a number validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/type.json number type matches numbers outputFormat = verbose, failFast = true a string is still not a number, even if it looks like one validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/type.json number type matches numbers outputFormat = verbose, failFast = true an array is not a number validateJSON() fails 1`] = `"should be a number but is an array instead"`;

exports[`tests/draft2020-12/type.json number type matches numbers outputFormat = verbose, failFast = true an object is not a number validateJSON() fails 1`] = `"should be a number but is an object instead"`;

exports[`tests/draft2020-12/type.json number type matches numbers outputFormat = verbose, failFast = true null is not a number validateJSON() fails 1`] = `"should be a number but is null instead"`;

exports[`tests/draft2020-12/type.json object type matches objects outputFormat = verbose, failFast = false a boolean is not an object validateJSON() fails 1`] = `"should be an object but is a boolean instead"`;

exports[`tests/draft2020-12/type.json object type matches objects outputFormat = verbose, failFast = false a float is not an object validateJSON() fails 1`] = `"should be an object but is a number instead"`;

exports[`tests/draft2020-12/type.json object type matches objects outputFormat = verbose, failFast = false a string is not an object validateJSON() fails 1`] = `"should be an object but is a string instead"`;

exports[`tests/draft2020-12/type.json object type matches objects outputFormat = verbose, failFast = false an array is not an object validateJSON() fails 1`] = `"should be an object but is an array instead"`;

exports[`tests/draft2020-12/type.json object type matches objects outputFormat = verbose, failFast = false an integer is not an object validateJSON() fails 1`] = `"should be an object but is an integer instead"`;

exports[`tests/draft2020-12/type.json object type matches objects outputFormat = verbose, failFast = false null is not an object validateJSON() fails 1`] = `"should be an object but is null instead"`;

exports[`tests/draft2020-12/type.json object type matches objects outputFormat = verbose, failFast = true a boolean is not an object validateJSON() fails 1`] = `"should be an object but is a boolean instead"`;

exports[`tests/draft2020-12/type.json object type matches objects outputFormat = verbose, failFast = true a float is not an object validateJSON() fails 1`] = `"should be an object but is a number instead"`;

exports[`tests/draft2020-12/type.json object type matches objects outputFormat = verbose, failFast = true a string is not an object validateJSON() fails 1`] = `"should be an object but is a string instead"`;

exports[`tests/draft2020-12/type.json object type matches objects outputFormat = verbose, failFast = true an array is not an object validateJSON() fails 1`] = `"should be an object but is an array instead"`;

exports[`tests/draft2020-12/type.json object type matches objects outputFormat = verbose, failFast = true an integer is not an object validateJSON() fails 1`] = `"should be an object but is an integer instead"`;

exports[`tests/draft2020-12/type.json object type matches objects outputFormat = verbose, failFast = true null is not an object validateJSON() fails 1`] = `"should be an object but is null instead"`;

exports[`tests/draft2020-12/type.json string type matches strings outputFormat = verbose, failFast = false 1 is not a string validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/type.json string type matches strings outputFormat = verbose, failFast = false a boolean is not a string validateJSON() fails 1`] = `"should be a string but is a boolean instead"`;

exports[`tests/draft2020-12/type.json string type matches strings outputFormat = verbose, failFast = false a float is not a string validateJSON() fails 1`] = `"should be a string but is a number instead"`;

exports[`tests/draft2020-12/type.json string type matches strings outputFormat = verbose, failFast = false an array is not a string validateJSON() fails 1`] = `"should be a string but is an array instead"`;

exports[`tests/draft2020-12/type.json string type matches strings outputFormat = verbose, failFast = false an object is not a string validateJSON() fails 1`] = `"should be a string but is an object instead"`;

exports[`tests/draft2020-12/type.json string type matches strings outputFormat = verbose, failFast = false null is not a string validateJSON() fails 1`] = `"should be a string but is null instead"`;

exports[`tests/draft2020-12/type.json string type matches strings outputFormat = verbose, failFast = true 1 is not a string validateJSON() fails 1`] = `"should be a string but is an integer instead"`;

exports[`tests/draft2020-12/type.json string type matches strings outputFormat = verbose, failFast = true a boolean is not a string validateJSON() fails 1`] = `"should be a string but is a boolean instead"`;

exports[`tests/draft2020-12/type.json string type matches strings outputFormat = verbose, failFast = true a float is not a string validateJSON() fails 1`] = `"should be a string but is a number instead"`;

exports[`tests/draft2020-12/type.json string type matches strings outputFormat = verbose, failFast = true an array is not a string validateJSON() fails 1`] = `"should be a string but is an array instead"`;

exports[`tests/draft2020-12/type.json string type matches strings outputFormat = verbose, failFast = true an object is not a string validateJSON() fails 1`] = `"should be a string but is an object instead"`;

exports[`tests/draft2020-12/type.json string type matches strings outputFormat = verbose, failFast = true null is not a string validateJSON() fails 1`] = `"should be a string but is null instead"`;

exports[`tests/draft2020-12/type.json type as array with one item outputFormat = verbose, failFast = false number is invalid validateJSON() fails 1`] = `"should be either a string but is an integer instead"`;

exports[`tests/draft2020-12/type.json type as array with one item outputFormat = verbose, failFast = true number is invalid validateJSON() fails 1`] = `"should be either a string but is an integer instead"`;

exports[`tests/draft2020-12/type.json type: array or object outputFormat = verbose, failFast = false null is invalid validateJSON() fails 1`] = `"should be either an array or an object but is null instead"`;

exports[`tests/draft2020-12/type.json type: array or object outputFormat = verbose, failFast = false number is invalid validateJSON() fails 1`] = `"should be either an array or an object but is an integer instead"`;

exports[`tests/draft2020-12/type.json type: array or object outputFormat = verbose, failFast = false string is invalid validateJSON() fails 1`] = `"should be either an array or an object but is a string instead"`;

exports[`tests/draft2020-12/type.json type: array or object outputFormat = verbose, failFast = true null is invalid validateJSON() fails 1`] = `"should be either an array or an object but is null instead"`;

exports[`tests/draft2020-12/type.json type: array or object outputFormat = verbose, failFast = true number is invalid validateJSON() fails 1`] = `"should be either an array or an object but is an integer instead"`;

exports[`tests/draft2020-12/type.json type: array or object outputFormat = verbose, failFast = true string is invalid validateJSON() fails 1`] = `"should be either an array or an object but is a string instead"`;

exports[`tests/draft2020-12/type.json type: array, object or null outputFormat = verbose, failFast = false number is invalid validateJSON() fails 1`] = `"should be either an array, an object or null but is an integer instead"`;

exports[`tests/draft2020-12/type.json type: array, object or null outputFormat = verbose, failFast = false string is invalid validateJSON() fails 1`] = `"should be either an array, an object or null but is a string instead"`;

exports[`tests/draft2020-12/type.json type: array, object or null outputFormat = verbose, failFast = true number is invalid validateJSON() fails 1`] = `"should be either an array, an object or null but is an integer instead"`;

exports[`tests/draft2020-12/type.json type: array, object or null outputFormat = verbose, failFast = true string is invalid validateJSON() fails 1`] = `"should be either an array, an object or null but is a string instead"`;

exports[`tests/draft2020-12/unevaluatedItems.json item is evaluated in an uncle schema to unevaluatedItems outputFormat = verbose, failFast = false uncle keyword evaluation is not significant validateJSON() fails 1`] = `"has an invalid property foo (has an invalid item at position 1 (should not be defined but is 'test'))"`;

exports[`tests/draft2020-12/unevaluatedItems.json item is evaluated in an uncle schema to unevaluatedItems outputFormat = verbose, failFast = true uncle keyword evaluation is not significant validateJSON() fails 1`] = `"has an invalid property (foo has an invalid item at position 1 (should not be defined but is 'test'))"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems and contains interact to control item dependency relationship outputFormat = verbose, failFast = false only a's and c's are invalid validateJSON() fails 1`] = `"has invalid items at positions 0, 2 and 4 (should not be defined but is 'c'; should not be defined but is 'c'; should not be defined but is 'c')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems and contains interact to control item dependency relationship outputFormat = verbose, failFast = false only b's and c's are invalid validateJSON() fails 1`] = `"has invalid items at positions 0, 1, 2, 3 and 4 (should not be defined but is 'c'; should not be defined but is 'b'; should not be defined but is 'c'; should not be defined but is 'b'; should not be defined but is 'c')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems and contains interact to control item dependency relationship outputFormat = verbose, failFast = false only b's are invalid validateJSON() fails 1`] = `"has invalid items at positions 0 and 1 (should not be defined but is 'b'; should not be defined but is 'b')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems and contains interact to control item dependency relationship outputFormat = verbose, failFast = false only c's are invalid validateJSON() fails 1`] = `"has invalid items at positions 0 and 1 (should not be defined but is 'c'; should not be defined but is 'c')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems and contains interact to control item dependency relationship outputFormat = verbose, failFast = true only a's and c's are invalid validateJSON() fails 1`] = `"has an invalid item at position 0 (should not be defined but is 'c')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems and contains interact to control item dependency relationship outputFormat = verbose, failFast = true only b's and c's are invalid validateJSON() fails 1`] = `"has an invalid item at position 0 (should not be defined but is 'c')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems and contains interact to control item dependency relationship outputFormat = verbose, failFast = true only b's are invalid validateJSON() fails 1`] = `"has an invalid item at position 0 (should not be defined but is 'b')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems and contains interact to control item dependency relationship outputFormat = verbose, failFast = true only c's are invalid validateJSON() fails 1`] = `"has an invalid item at position 0 (should not be defined but is 'c')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems as schema outputFormat = verbose, failFast = false with invalid unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 0 (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems as schema outputFormat = verbose, failFast = true with invalid unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 0 (should be a string but is an integer instead)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems can see annotations from if without then and else outputFormat = verbose, failFast = false invalid in case if is evaluated validateJSON() fails 1`] = `"has an invalid item at position 0 (should not be defined but is 'b')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems can see annotations from if without then and else outputFormat = verbose, failFast = true invalid in case if is evaluated validateJSON() fails 1`] = `"has an invalid item at position 0 (should not be defined but is 'b')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems can't see inside cousins outputFormat = verbose, failFast = false always fails validateJSON() fails 1`] = `"has an invalid item at position 0 (should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems can't see inside cousins outputFormat = verbose, failFast = true always fails validateJSON() fails 1`] = `"has an invalid item at position 0 (should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems depends on adjacent contains outputFormat = verbose, failFast = false contains fails, second item is not evaluated validateJSON() fails 1`] = `"does not contain an item that validates against a subschema; has an invalid item at position 1 (should not be defined but is 2)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems depends on adjacent contains outputFormat = verbose, failFast = false contains passes, second item is not evaluated validateJSON() fails 1`] = `"has an invalid item at position 1 (should not be defined but is 2)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems depends on adjacent contains outputFormat = verbose, failFast = true contains fails, second item is not evaluated validateJSON() fails 1`] = `"does not contain an item that validates against a subschema"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems depends on adjacent contains outputFormat = verbose, failFast = true contains passes, second item is not evaluated validateJSON() fails 1`] = `"has an invalid item at position 1 (should not be defined but is 2)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems depends on multiple nested contains outputFormat = verbose, failFast = false 7 not evaluated, fails unevaluatedItems validateJSON() fails 1`] = `"has an invalid item at position 3 (should be a multiple of 5 but is 7 instead)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems depends on multiple nested contains outputFormat = verbose, failFast = true 7 not evaluated, fails unevaluatedItems validateJSON() fails 1`] = `"has an invalid item at position 3 (should be a multiple of 5 but is 7 instead)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems false outputFormat = verbose, failFast = false with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 0 (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems false outputFormat = verbose, failFast = true with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 0 (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with $ref outputFormat = verbose, failFast = false with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 2 (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with $ref outputFormat = verbose, failFast = true with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 2 (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with anyOf outputFormat = verbose, failFast = false when one schema matches and has unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 2 (should not be defined but is 42)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with anyOf outputFormat = verbose, failFast = false when two schemas match and has unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 3 (should not be defined but is 42)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with anyOf outputFormat = verbose, failFast = true when one schema matches and has unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 2 (should not be defined but is 42)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with anyOf outputFormat = verbose, failFast = true when two schemas match and has unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 3 (should not be defined but is 42)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with boolean schemas outputFormat = verbose, failFast = false with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 0 (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with boolean schemas outputFormat = verbose, failFast = true with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 0 (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with if/then/else outputFormat = verbose, failFast = false when if doesn't match and it has unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 4 (should not be defined but is 42)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with if/then/else outputFormat = verbose, failFast = false when if matches and it has unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 3 (should not be defined but is 'else')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with if/then/else outputFormat = verbose, failFast = true when if doesn't match and it has unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 4 (should not be defined but is 42)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with if/then/else outputFormat = verbose, failFast = true when if matches and it has unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 3 (should not be defined but is 'else')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with items outputFormat = verbose, failFast = false invalid under items validateJSON() fails 1`] = `"has invalid items at positions 0, 1 and 2 (should be a number but is a string instead; should be a number but is a string instead; should be a number but is a string instead)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with items outputFormat = verbose, failFast = true invalid under items validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with nested items outputFormat = verbose, failFast = false with invalid additional item validateJSON() fails 1`] = `"has an invalid item at position 0 (should be a boolean but is a string instead)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with nested items outputFormat = verbose, failFast = true with invalid additional item validateJSON() fails 1`] = `"has an invalid item at position 0 (should be a boolean but is a string instead)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with nested tuple outputFormat = verbose, failFast = false with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 2 (should not be defined but is true)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with nested tuple outputFormat = verbose, failFast = true with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 2 (should not be defined but is true)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with not outputFormat = verbose, failFast = false with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 1 (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with not outputFormat = verbose, failFast = true with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 1 (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with oneOf outputFormat = verbose, failFast = false with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 2 (should not be defined but is 42)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with oneOf outputFormat = verbose, failFast = true with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 2 (should not be defined but is 42)"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with tuple outputFormat = verbose, failFast = false with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 1 (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedItems.json unevaluatedItems with tuple outputFormat = verbose, failFast = true with unevaluated items validateJSON() fails 1`] = `"has an invalid item at position 1 (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json cousin unevaluatedProperties, true and false, false with properties outputFormat = verbose, failFast = false with nested unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json cousin unevaluatedProperties, true and false, false with properties outputFormat = verbose, failFast = true with nested unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json cousin unevaluatedProperties, true and false, true with properties outputFormat = verbose, failFast = false with nested unevaluated properties validateJSON() fails 1`] = `"has invalid properties 'foo' and 'bar' (should not be defined but is 'foo'; should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json cousin unevaluatedProperties, true and false, true with properties outputFormat = verbose, failFast = false with no nested unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json cousin unevaluatedProperties, true and false, true with properties outputFormat = verbose, failFast = true with nested unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json cousin unevaluatedProperties, true and false, true with properties outputFormat = verbose, failFast = true with no nested unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false Empty is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false a + b is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2; has invalid properties 'a' and 'b' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false a + c is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2; has invalid properties 'a' and 'c' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false a + d is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2; has invalid properties 'a' and 'd' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false all + a is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2; has invalid properties 'all' and 'a' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false b + c is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none; has invalid properties 'b' and 'c' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false b + d is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none; has invalid properties 'b' and 'd' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false c + d is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none; has invalid properties 'c' and 'd' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false xx + a is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2; has invalid properties 'xx' and 'a' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false xx + b is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none; has invalid properties 'xx' and 'b' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false xx + c is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none; has invalid properties 'xx' and 'c' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false xx + d is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none; has invalid properties 'xx' and 'd' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = false xx + foo is invalid validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true Empty is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true a + b is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true a + c is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true a + d is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true all + a is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true b + c is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true b + d is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true c + d is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true xx + a is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true xx + b is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true xx + c is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true xx + d is invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/unevaluatedProperties.json dynamic evalation inside nested refs outputFormat = verbose, failFast = true xx + foo is invalid validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json in-place applicator siblings, allOf has unevaluated outputFormat = verbose, failFast = false base case: both properties present validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json in-place applicator siblings, allOf has unevaluated outputFormat = verbose, failFast = false in place applicator siblings, foo is missing validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json in-place applicator siblings, allOf has unevaluated outputFormat = verbose, failFast = true base case: both properties present validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json in-place applicator siblings, allOf has unevaluated outputFormat = verbose, failFast = true in place applicator siblings, foo is missing validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json in-place applicator siblings, anyOf has unevaluated outputFormat = verbose, failFast = false base case: both properties present validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/unevaluatedProperties.json in-place applicator siblings, anyOf has unevaluated outputFormat = verbose, failFast = false in place applicator siblings, bar is missing validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/unevaluatedProperties.json in-place applicator siblings, anyOf has unevaluated outputFormat = verbose, failFast = true base case: both properties present validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/unevaluatedProperties.json in-place applicator siblings, anyOf has unevaluated outputFormat = verbose, failFast = true in place applicator siblings, bar is missing validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/unevaluatedProperties.json nested unevaluatedProperties, outer true, inner false, properties inside outputFormat = verbose, failFast = false with nested unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json nested unevaluatedProperties, outer true, inner false, properties inside outputFormat = verbose, failFast = true with nested unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json nested unevaluatedProperties, outer true, inner false, properties outside outputFormat = verbose, failFast = false with nested unevaluated properties validateJSON() fails 1`] = `"has invalid properties 'foo' and 'bar' (should not be defined but is 'foo'; should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json nested unevaluatedProperties, outer true, inner false, properties outside outputFormat = verbose, failFast = false with no nested unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json nested unevaluatedProperties, outer true, inner false, properties outside outputFormat = verbose, failFast = true with nested unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json nested unevaluatedProperties, outer true, inner false, properties outside outputFormat = verbose, failFast = true with no nested unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json property is evaluated in an uncle schema to unevaluatedProperties outputFormat = verbose, failFast = false uncle keyword evaluation is not significant validateJSON() fails 1`] = `"has an invalid property foo (has an invalid property faz (should not be defined but is 'test'))"`;

exports[`tests/draft2020-12/unevaluatedProperties.json property is evaluated in an uncle schema to unevaluatedProperties outputFormat = verbose, failFast = true uncle keyword evaluation is not significant validateJSON() fails 1`] = `"has an invalid property (foo has an invalid property faz (should not be defined but is 'test'))"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + ref inside allOf / oneOf outputFormat = verbose, failFast = false Empty is invalid (no x or y) validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + ref inside allOf / oneOf outputFormat = verbose, failFast = false a and b and x and y are invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2; has invalid properties 'a', 'b', 'x' and 'y' (should not be defined but is 1; should not be defined but is 1; should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + ref inside allOf / oneOf outputFormat = verbose, failFast = false a and b are invalid (no x or y) validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none; has invalid properties 'a' and 'b' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + ref inside allOf / oneOf outputFormat = verbose, failFast = false x and y are invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2; has invalid properties 'x' and 'y' (should not be defined but is 1; should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + ref inside allOf / oneOf outputFormat = verbose, failFast = true Empty is invalid (no x or y) validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + ref inside allOf / oneOf outputFormat = verbose, failFast = true a and b and x and y are invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + ref inside allOf / oneOf outputFormat = verbose, failFast = true a and b are invalid (no x or y) validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against none"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + ref inside allOf / oneOf outputFormat = verbose, failFast = true x and y are invalid validateJSON() fails 1`] = `"should validate against exactly one subschema but validates against 2"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + single cyclic ref outputFormat = verbose, failFast = false Unevaluated on 1st level is invalid validateJSON() fails 1`] = `"has an invalid property y (should not be defined but is {})"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + single cyclic ref outputFormat = verbose, failFast = false Unevaluated on 2nd level is invalid validateJSON() fails 1`] = `"has an invalid property x (has an invalid property y (should not be defined but is {})); has an invalid property x (should not be defined but is {"x":{},"y":{}})"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + single cyclic ref outputFormat = verbose, failFast = false Unevaluated on 3rd level is invalid validateJSON() fails 1`] = `"has an invalid property x (has an invalid property x (has an invalid property y (should not be defined but is {})); has an invalid property x (should not be defined but is {"x":{},"y":{}})); has an invalid property x (should not be defined but is {"x":{"x":{},"y":{}}})"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + single cyclic ref outputFormat = verbose, failFast = true Unevaluated on 1st level is invalid validateJSON() fails 1`] = `"has an invalid property y (should not be defined but is {})"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + single cyclic ref outputFormat = verbose, failFast = true Unevaluated on 2nd level is invalid validateJSON() fails 1`] = `"has an invalid property (x has an invalid property y (should not be defined but is {}))"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties + single cyclic ref outputFormat = verbose, failFast = true Unevaluated on 3rd level is invalid validateJSON() fails 1`] = `"has an invalid property (x has an invalid property (x has an invalid property y (should not be defined but is {})))"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties can see annotations from if without then and else outputFormat = verbose, failFast = false invalid in case if is evaluated validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'a')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties can see annotations from if without then and else outputFormat = verbose, failFast = true invalid in case if is evaluated validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'a')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties can't see inside cousins (reverse order) outputFormat = verbose, failFast = false always fails validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties can't see inside cousins (reverse order) outputFormat = verbose, failFast = true always fails validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties can't see inside cousins outputFormat = verbose, failFast = false always fails validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties can't see inside cousins outputFormat = verbose, failFast = true always fails validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 1)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties false outputFormat = verbose, failFast = false with unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties false outputFormat = verbose, failFast = true with unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'foo')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties not affected by propertyNames outputFormat = verbose, failFast = false string property is invalid validateJSON() fails 1`] = `"has an invalid property a (should be a number but is a string instead)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties not affected by propertyNames outputFormat = verbose, failFast = true string property is invalid validateJSON() fails 1`] = `"has an invalid property a (should be a number but is a string instead)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties schema outputFormat = verbose, failFast = false with invalid unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should have at least 3 characters but has 2 instead)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties schema outputFormat = verbose, failFast = true with invalid unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should have at least 3 characters but has 2 instead)"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with $ref outputFormat = verbose, failFast = false with unevaluated properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with $ref outputFormat = verbose, failFast = true with unevaluated properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with adjacent patternProperties outputFormat = verbose, failFast = false with unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with adjacent patternProperties outputFormat = verbose, failFast = true with unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with adjacent properties outputFormat = verbose, failFast = false with unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with adjacent properties outputFormat = verbose, failFast = true with unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with anyOf outputFormat = verbose, failFast = false when one matches and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'not-baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with anyOf outputFormat = verbose, failFast = false when two match and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property quux (should not be defined but is 'not-quux')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with anyOf outputFormat = verbose, failFast = true when one matches and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'not-baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with anyOf outputFormat = verbose, failFast = true when two match and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property quux (should not be defined but is 'not-quux')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with boolean schemas outputFormat = verbose, failFast = false with unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with boolean schemas outputFormat = verbose, failFast = true with unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with dependentSchemas outputFormat = verbose, failFast = false with unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with dependentSchemas outputFormat = verbose, failFast = true with unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else outputFormat = verbose, failFast = false when if is false and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'else')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else outputFormat = verbose, failFast = false when if is true and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else outputFormat = verbose, failFast = true when if is false and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'else')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else outputFormat = verbose, failFast = true when if is true and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else, else not defined outputFormat = verbose, failFast = false when if is false and has no unevaluated properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else, else not defined outputFormat = verbose, failFast = false when if is false and has unevaluated properties validateJSON() fails 1`] = `"has invalid properties 'foo' and 'baz' (should not be defined but is 'else'; should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else, else not defined outputFormat = verbose, failFast = false when if is true and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else, else not defined outputFormat = verbose, failFast = true when if is false and has no unevaluated properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else, else not defined outputFormat = verbose, failFast = true when if is false and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'else')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else, else not defined outputFormat = verbose, failFast = true when if is true and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else, then not defined outputFormat = verbose, failFast = false when if is false and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'else')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else, then not defined outputFormat = verbose, failFast = false when if is true and has no unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else, then not defined outputFormat = verbose, failFast = false when if is true and has unevaluated properties validateJSON() fails 1`] = `"has invalid properties 'bar' and 'baz' (should not be defined but is 'bar'; should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else, then not defined outputFormat = verbose, failFast = true when if is false and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property foo (should not be defined but is 'else')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else, then not defined outputFormat = verbose, failFast = true when if is true and has no unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with if/then/else, then not defined outputFormat = verbose, failFast = true when if is true and has unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with nested patternProperties outputFormat = verbose, failFast = false with additional properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with nested patternProperties outputFormat = verbose, failFast = true with additional properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with nested properties outputFormat = verbose, failFast = false with additional properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with nested properties outputFormat = verbose, failFast = true with additional properties validateJSON() fails 1`] = `"has an invalid property baz (should not be defined but is 'baz')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with not outputFormat = verbose, failFast = false with unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with not outputFormat = verbose, failFast = true with unevaluated properties validateJSON() fails 1`] = `"has an invalid property bar (should not be defined but is 'bar')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with oneOf outputFormat = verbose, failFast = false with unevaluated properties validateJSON() fails 1`] = `"has an invalid property quux (should not be defined but is 'quux')"`;

exports[`tests/draft2020-12/unevaluatedProperties.json unevaluatedProperties with oneOf outputFormat = verbose, failFast = true with unevaluated properties validateJSON() fails 1`] = `"has an invalid property quux (should not be defined but is 'quux')"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = false non-unique array of arrays is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = false non-unique array of integers is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = false non-unique array of more than two arrays is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 2 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = false non-unique array of more than two integers is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 2 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = false non-unique array of nested objects is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = false non-unique array of objects is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = false non-unique array of strings is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 2 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = false non-unique heterogeneous types are invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 4 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = false numbers are unique if mathematically unequal validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal, items at 0 and 2 are equal and items at 1 and 2 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = false objects are non-unique despite key order validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = false property order of array of objects is ignored validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = true non-unique array of arrays is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = true non-unique array of integers is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = true non-unique array of more than two arrays is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 2 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = true non-unique array of more than two integers is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 2 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = true non-unique array of nested objects is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = true non-unique array of objects is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = true non-unique array of strings is invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 2 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = true non-unique heterogeneous types are invalid validateJSON() fails 1`] = `"should have unique items but items at 0 and 4 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = true numbers are unique if mathematically unequal validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = true objects are non-unique despite key order validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems validation outputFormat = verbose, failFast = true property order of array of objects is ignored validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items and additionalItems=false outputFormat = verbose, failFast = false [false, false] from items array is not valid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items and additionalItems=false outputFormat = verbose, failFast = false [true, true] from items array is not valid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items and additionalItems=false outputFormat = verbose, failFast = false extra items are invalid even if unique validateJSON() fails 1`] = `"has an invalid item at position 2 (should not be defined but is null)"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items and additionalItems=false outputFormat = verbose, failFast = true [false, false] from items array is not valid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items and additionalItems=false outputFormat = verbose, failFast = true [true, true] from items array is not valid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items and additionalItems=false outputFormat = verbose, failFast = true extra items are invalid even if unique validateJSON() fails 1`] = `"should not be defined but is null"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items outputFormat = verbose, failFast = false [false, false] from items array is not valid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items outputFormat = verbose, failFast = false [true, true] from items array is not valid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items outputFormat = verbose, failFast = false non-unique array extended from [false, true] is not valid validateJSON() fails 1`] = `"should have unique items but items at 2 and 3 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items outputFormat = verbose, failFast = false non-unique array extended from [true, false] is not valid validateJSON() fails 1`] = `"should have unique items but items at 2 and 3 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items outputFormat = verbose, failFast = true [false, false] from items array is not valid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items outputFormat = verbose, failFast = true [true, true] from items array is not valid validateJSON() fails 1`] = `"should have unique items but items at 0 and 1 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items outputFormat = verbose, failFast = true non-unique array extended from [false, true] is not valid validateJSON() fails 1`] = `"should have unique items but items at 2 and 3 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems with an array of items outputFormat = verbose, failFast = true non-unique array extended from [true, false] is not valid validateJSON() fails 1`] = `"should have unique items but items at 2 and 3 are equal instead"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems=false with an array of items and additionalItems=false outputFormat = verbose, failFast = false extra items are invalid even if unique validateJSON() fails 1`] = `"has an invalid item at position 2 (should not be defined but is null)"`;

exports[`tests/draft2020-12/uniqueItems.json uniqueItems=false with an array of items and additionalItems=false outputFormat = verbose, failFast = true extra items are invalid even if unique validateJSON() fails 1`] = `"should not be defined but is null"`;

exports[`tests/draft2020-12/unknownKeyword.json $id inside an unknown keyword is not a real identifier outputFormat = verbose, failFast = false type matches non-schema in first anyOf validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/unknownKeyword.json $id inside an unknown keyword is not a real identifier outputFormat = verbose, failFast = false type matches non-schema in third anyOf validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/unknownKeyword.json $id inside an unknown keyword is not a real identifier outputFormat = verbose, failFast = true type matches non-schema in first anyOf validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/unknownKeyword.json $id inside an unknown keyword is not a real identifier outputFormat = verbose, failFast = true type matches non-schema in third anyOf validateJSON() fails 1`] = `"does not validate against any subschema"`;

exports[`tests/draft2020-12/vocabulary.json ignore unrecognized optional vocabulary outputFormat = verbose, failFast = false string value validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/vocabulary.json ignore unrecognized optional vocabulary outputFormat = verbose, failFast = true string value validateJSON() fails 1`] = `"should be a number but is a string instead"`;

exports[`tests/draft2020-12/vocabulary.json schema that uses custom metaschema with with no validation vocabulary outputFormat = verbose, failFast = false applicator vocabulary still works validateJSON() fails 1`] = `"has an invalid property badProperty (should not be defined but is 'this property should not exist')"`;

exports[`tests/draft2020-12/vocabulary.json schema that uses custom metaschema with with no validation vocabulary outputFormat = verbose, failFast = true applicator vocabulary still works validateJSON() fails 1`] = `"has an invalid property (badProperty should not be defined but is 'this property should not exist')"`;
